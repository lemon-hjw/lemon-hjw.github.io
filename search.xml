<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP/IP网络编程（五）</title>
      <link href="/2023/06/05/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/"/>
      <url>/2023/06/05/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</url>
      
        <content type="html"><![CDATA[<h2 id="13-epoll"><a href="#13-epoll" class="headerlink" title="13.epoll"></a>13.epoll</h2><p>select复用无论如何优化程序性能也无法同时接入上百个客户，所以并不适合web服务器端开发为主流的现代开发环境，所以要学习Linux平台下的epoll。</p><h3 id="（1）epoll必要的函数和结构体"><a href="#（1）epoll必要的函数和结构体" class="headerlink" title="（1）epoll必要的函数和结构体"></a>（1）epoll必要的函数和结构体</h3><p>epoll方式通过如下结构体将发生变化的文件描述符单独集中在一起：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct epoll_event&#123;    __uint32_t events;    epoll_data_t data;&#125;        typedef union epoll_data        &#123;            void * ptr;            int fd;            __uint32_t u32;            __uint64_t u64;        &#125;epoll_data_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>epoll_event的成员events中可以保存的常量及所指的事件类型：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXaZj.png"></p><p><strong>epoll_create</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_create(int size);&#x2F;&#x2F;成epoll文件描述符，败-1&#x2F;&#x2F;size，epoll实例大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>epoll_ctl</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_ctl(int epfd,int op,int fd,struct epoll_event * event);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXDJ0.png"></p><p>第二个参数传递的常量及含义：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXdds.png"></p><p><strong>epoll_wait</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);&#x2F;&#x2F;成返回发生事件的文件描述符，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXtsg.png"></p><h3 id="（2）基于epoll的回声服务器端"><a href="#（2）基于epoll的回声服务器端" class="headerlink" title="（2）基于epoll的回声服务器端"></a>（2）基于epoll的回声服务器端</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#define BUF_SIZE 100#define EPOLL_SIZE 50void error_handling(char * buf);int main(int argc, char * argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t adr_sz;    int str_len;    char buf[BUF_SIZE];    struct epoll_event *ep_events;    struct epoll_event event;    int epfd,event_cnt;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htons(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    epfd&#x3D;epoll_create(EPOLL_SIZE);    ep_events&#x3D;malloc(sizeof(struct epoll_event)*EPOLL_SIZE);    event.events&#x3D;EPOLLIN;    event.data.fd&#x3D;serv_sock;    epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event);    while(1)    &#123;        event_cnt&#x3D;epoll_wait(epfd,ep_events,EPOLL_SIZE,-1);        if(event_cnt&#x3D;&#x3D;-1)        &#123;            puts(&quot;epoll_wait error&quot;);            break;        &#125;        for(int i&#x3D;0;i&lt;event_cnt;++i)        &#123;            if(ep_events[i].data.fd&#x3D;&#x3D;serv_sock)            &#123;                adr_sz&#x3D;sizeof(clnt_adr);                clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                event.events&#x3D;EPOLLIN;                event.data.fd&#x3D;clnt_sock;                epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event);                printf(&quot;connected client:%d\n&quot;,clnt_sock);            &#125;            else&#123;                str_len&#x3D;read(ep_events[i].data.fd,buf,BUF_SIZE);                if(str_len&#x3D;&#x3D;0)                &#123;                    epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL);                    close(ep_events[i].data.fd);                    printf(&quot;closed client:%d\n&quot;,ep_events[i].data.fd);                &#125;                else&#123;                    write(ep_events[i].data.fd,buf,str_len);                &#125;            &#125;        &#125;            &#125;    close(serv_sock);            close(epfd);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-实现边缘触发的回声服务器端"><a href="#3-实现边缘触发的回声服务器端" class="headerlink" title="(3)实现边缘触发的回声服务器端"></a>(3)实现边缘触发的回声服务器端</h3><p>边缘触发方式中，接收数据时仅注册一次该事件，一旦发生输入相关事件，就应该读取输入缓冲中全部数据，因此需要验证输入缓冲是否为空。read函数返回-1，变量errno中的值为EAGAIN时，说明没有数据可读。需要套接字变成非阻塞方式，否则以阻塞方式共做的read&amp;write函数可能引起服务器端长时间停顿。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;fcntl.h&gt;#include&lt;errno.h&gt;#define BUF_SIZE 4#define EPOLL_SIZE 50void setnonblockingmode(int fd);void error_handling(char * buf);int main(int argc, char * argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t adr_sz;    int str_len;    char buf[BUF_SIZE];    struct epoll_event *ep_events;    struct epoll_event event;    int epfd,event_cnt;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htons(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    epfd&#x3D;epoll_create(EPOLL_SIZE);    ep_events&#x3D;malloc(sizeof(struct epoll_event)*EPOLL_SIZE);    event.events&#x3D;EPOLLIN;    event.data.fd&#x3D;serv_sock;    epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event);    while(1)    &#123;        event_cnt&#x3D;epoll_wait(epfd,ep_events,EPOLL_SIZE,-1);        if(event_cnt&#x3D;&#x3D;-1)        &#123;            puts(&quot;epoll_wait error&quot;);            break;        &#125;        puts(&quot;return epoll_wait&quot;);        for(int i&#x3D;0;i&lt;event_cnt;++i)        &#123;            if(ep_events[i].data.fd&#x3D;&#x3D;serv_sock)            &#123;                adr_sz&#x3D;sizeof(clnt_adr);                clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                setnonblockingmode(clnt_sock);                event.events&#x3D;EPOLLIN|EPOLLET;                event.data.fd&#x3D;clnt_sock;                epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event);                printf(&quot;connected client:%d\n&quot;,clnt_sock);            &#125;            else&#123;                while(1)                &#123;                    str_len&#x3D;read(ep_events[i].data.fd,buf,BUF_SIZE);                    if(str_len&#x3D;&#x3D;0)                    &#123;                        epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL);                        close(ep_events[i].data.fd);                        printf(&quot;closed client:%d\n&quot;,ep_events[i].data.fd);                        break;                    &#125;                    else if(str_len&lt;0)                    &#123;                        if(errno&#x3D;&#x3D;EAGAIN)                            break;                    &#125;                    else&#123;                        write(ep_events[i].data.fd,buf,str_len);                    &#125;                 &#125;                            &#125;        &#125;            &#125;    close(serv_sock);    close(epfd);    return 0;&#125;void setnonblockingmode(int fd)&#123;    int flag&#x3D;fcntl(fd,F_GETFL,0);    fcntl(fd,F_SETFL,flag|O_NONBLOCK);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-多线程服务器端的实现"><a href="#14-多线程服务器端的实现" class="headerlink" title="14.多线程服务器端的实现"></a>14.多线程服务器端的实现</h2><h3 id="（1）线程和进程的差异："><a href="#（1）线程和进程的差异：" class="headerlink" title="（1）线程和进程的差异："></a>（1）线程和进程的差异：</h3><p>进程间独立的内存：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXYQS.png"></p><p>线程的内存结构：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXNLQ.png"></p><h3 id="（2）线程创建和运行"><a href="#（2）线程创建和运行" class="headerlink" title="（2）线程创建和运行"></a>（2）线程创建和运行</h3><p>线程具有单独的执行流，因此需要单独定义线程的main函数，还需请求操作系统在单独的执行流中执行该函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_create(    pthread_t * restrict thread,const pthread_attr_t * restrict attr,    void  * (* start_routine)(void *),void * restrict arg);&#x2F;&#x2F;成0，败返回其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXNLQ.png"></p><p>通过下列代码了解该函数的功能：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;void* thread_main(void *arg);int main(int argc,char *argv[])&#123;    pthread_t t_id;    int thread_param&#x3D;5;    if(pthread_create(&amp;t_id,NULL,thread_main,(void*)&amp;thread_param)!&#x3D;0)    &#123;        puts(&quot;pthread_create() error&quot;);        return -1;    &#125;    sleep(10);    puts(&quot;end of main&quot;);    return 0;&#125;void* thread_main(void * arg)&#123;    int cnt&#x3D;*((int*)arg);    for(int i&#x3D;0;i&lt;cnt;++i)    &#123;        sleep(1);puts(&quot;running thread&quot;);    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXwon.png"></p><p>执行流程：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXrWV.png"></p><p>将sleep（10）改为sleep（2）将不会输出5次running thread，因为main函数返回后整个进程将被销毁。通常利用下面的函数控制线程的执行流：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_join(pthread_t thread,void ** status);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;thread  该参数id的线程终止后才会从该函数返回&#x2F;&#x2F;status 保存线程的main函数返回值的指针变量地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;void* thread_main(void *arg);int main(int argc,char *argv[])&#123;    pthread_t t_id;    int thread_param&#x3D;5;    void * thr_ret;    if(pthread_create(&amp;t_id,NULL,thread_main,(void*)&amp;thread_param)!&#x3D;0)    &#123;        puts(&quot;pthread_create() error&quot;);        return -1;    &#125;    if(pthread_join(t_id,&amp;thr_ret)!&#x3D;0)    &#123;        puts(&quot;pthread_join() error&quot;);        return -1;    &#125;    printf(&quot;pthread return message:%s\n&quot;,(char*)thr_ret);    free(thr_ret);    return 0;&#125;void* thread_main(void * arg)&#123;    int cnt&#x3D;*((int*)arg);    char * msg&#x3D;(char*)malloc(sizeof(char)*50);    strcpy(msg,&quot;hello,I&#39;m thread~\n&quot;);    for(int i&#x3D;0;i&lt;cnt;++i)    &#123;        sleep(1);puts(&quot;running thread&quot;);    &#125;    return (void*)msg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流程图：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCX6QU.png"></p><h3 id="（3）互斥量"><a href="#（3）互斥量" class="headerlink" title="（3）互斥量"></a>（3）互斥量</h3><p><strong>创建及销毁</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t * attr);int pthread_mutex_destroy(pthread_mutex_t * mutex);&#x2F;&#x2F;成0，败其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXszT.png"></p><p><strong>互斥量锁住或释放临界区时使用的函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);&#x2F;&#x2F;成0，败返回其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）信号量"><a href="#（4）信号量" class="headerlink" title="（4）信号量"></a>（4）信号量</h3><p><strong>创建及销毁</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;semaphore.h&gt;int sem_init(sem_t *sem,int pshared,unsigned int value);int sem_destroy(sem_t *sem);&#x2F;&#x2F;成0，败其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXcyF.png"></p><p><strong>下面函数相当于互斥量的lock和unlock函数：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;semaphore.h&gt;int sem_post(sem_t * sem);int sem_wait(sem_t * sem);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;sem，传递信号量读取值的变量地址值，传递给sem_post时信号量增1，反之-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（5）线程的销毁和多线程并发服务器端的实现"><a href="#（5）线程的销毁和多线程并发服务器端的实现" class="headerlink" title="（5）线程的销毁和多线程并发服务器端的实现"></a>（5）线程的销毁和多线程并发服务器端的实现</h3><p>调用pthread_join函数时，不仅会等待线程种植，还会引导线程销毁。但线程终止前调用该函数的线程将进入阻塞状态。因此通常通过如下函数调用引导线程销毁：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_detach(pthread_t thread);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;thread，终止时同时需要销毁的线程id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>聊天程序服务器端：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 100#define MAX_CLNT 256void * handle_clnt(void *arg);void send_msg(char * msg,int len);void error_handling(char * message);int clnt_cnt&#x3D;0;int clnt_socks[MAX_CLNT];pthread_mutex_t mutex;int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int clnt_adr_sz;    pthread_t t_id;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s &lt;port&gt;\n&quot;, argv[0]);        exit(1);    &#125;    pthread_mutex_init(&amp;mutex,NULL);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_sock,&amp;clnt_adr_sz);        pthread_mutex_lock(&amp;mutex);        clnt_socks[clnt_cnt++]&#x3D;clnt_sock;        pthread_mutex_unlock(&amp;mutex);        pthread_create(&amp;t_id,NULL,handle_clnt,(void*)&amp;clnt_sock);        pthread_detach(t_id);        printf(&quot;connected client IP :%s\n&quot;,inet_ntoa(clnt_adr.sin_addr));    &#125;    close(serv_sock);    return 0;&#125;void * handle_clnt(void *arg)&#123;    int clnt_sock&#x3D;*((int*)arg);    int str_len&#x3D;0;    char msg[BUF_SIZE];    while((str_len&#x3D;read(clnt_sock,msg,sizeof(msg)))!&#x3D;0)        send_msg(msg,str_len);    pthread_mutex_lock(&amp;mutex);    for(int i&#x3D;0;i&lt;clnt_cnt;++i)    &#123;        if(clnt_sock&#x3D;&#x3D;clnt_socks[i])        &#123;            while(i++&lt;clnt_cnt-1)                clnt_socks[i]&#x3D;clnt_socks[i+1];            break;        &#125;    &#125;    clnt_cnt--;    pthread_mutex_unlock(&amp;mutex);    close(clnt_sock);    return NULL;&#125;void send_msg(char *msg,int len)&#123;    pthread_mutex_lock(&amp;mutex);    for(int i&#x3D;0;i&lt;clnt_cnt;++i)    &#123;        write(clnt_socks[i],msg,len);    &#125;    pthread_mutex_unlock(&amp;mutex);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>聊天程序客户端：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 100#define NAME_SIZE 20void * send_msg(void * arg);void * recv_msg(void * arg);void error_handling(char *msg);char name[NAME_SIZE]&#x3D;&quot;[DEFAULT]&quot;;char msg[BUF_SIZE];int main(int argc,char *argv[])&#123;    int sock;    struct sockaddr_in serv_addr;    pthread_t snd_thread,rcv_thread;    void * thread_return;    if(argc!&#x3D;4)    &#123;        printf(&quot;Usage:%s&lt;ip&gt;&lt;port&gt;&lt;name&gt;\n&quot;, argv[0]);        exit(1);    &#125;    sprintf(name,&quot;[%s]&quot;,argv[3]);    sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    memset(&amp;serv_addr,0,sizeof(serv_addr));    serv_addr.sin_family &#x3D; AF_INET;    serv_addr.sin_addr.s_addr &#x3D;inet_addr(argv[1]);    serv_addr.sin_port &#x3D; htons(atoi(argv[2]));    if(connect(sock, (struct sockaddr *)&amp;serv_addr,sizeof(serv_addr))&#x3D;&#x3D;-1)        error_handling(&quot;connect error&quot;);     pthread_create(&amp;snd_thread, NULL,send_msg,(void*)&amp;sock);    pthread_create(&amp;rcv_thread, NULL,recv_msg,(void*)&amp;sock);    pthread_join(snd_thread, &amp;thread_return);    pthread_join(rcv_thread, &amp;thread_return);    close(sock);    return 0;&#125;void * send_msg(void * arg)&#123;    int sock&#x3D;*((int*)arg);    char name_msg[NAME_SIZE+BUF_SIZE];    while(1)    &#123;        fgets(msg,BUF_SIZE,stdin);        if(!strcmp(msg,&quot;q\n&quot;)||!strcmp(msg,&quot;Q\n&quot;))        &#123;            close(sock);            exit(0);        &#125;        sprintf(name_msg,&quot;%s %s&quot;,name,msg);        write(sock,name_msg,strlen(name_msg));    &#125;    return NULL;&#125;void * recv_msg(void * arg)&#123;    int sock&#x3D;*((int*)arg);    char name_msg[NAME_SIZE+BUF_SIZE];    int str_len;    while(1)    &#123;        str_len&#x3D;read(sock,name_msg,NAME_SIZE+BUF_SIZE-1);        if(str_len&#x3D;&#x3D;-1) return (void*)-1;        name_msg[str_len]&#x3D;0;        fputs(name_msg,stdout);    &#125;    return NULL;&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-HTTP服务器端"><a href="#15-HTTP服务器端" class="headerlink" title="15.HTTP服务器端"></a>15.HTTP服务器端</h2><h3 id="（1）了解HTTP协议"><a href="#（1）了解HTTP协议" class="headerlink" title="（1）了解HTTP协议"></a>（1）了解HTTP协议</h3><p>请求&#x2F;响应过程：</p><p>服务武器不会维持客户端状态，称为无状态的Stateless协议</p><p><img src="https://s1.ax1x.com/2023/06/14/pCnlCcD.png"></p><h4 id="请求消息的结构"><a href="#请求消息的结构" class="headerlink" title="请求消息的结构"></a>请求消息的结构</h4><p><img src="https://s1.ax1x.com/2023/06/14/pCnlFnH.png"></p><h4 id="响应消息的结构"><a href="#响应消息的结构" class="headerlink" title="响应消息的结构"></a>响应消息的结构</h4><p><img src="https://s1.ax1x.com/2023/06/14/pCnl91O.png"></p><h3 id="（2）实现Web服务器端"><a href="#（2）实现Web服务器端" class="headerlink" title="（2）实现Web服务器端"></a>（2）实现Web服务器端</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 1024#define SMALL_BUF 100void * request_handler(void *arg);void send_data(FILE *fp,char *ct,char *file_name);char *content_type(char *file);void send_error(FILE *fp);int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int clnt_adr_size;    char buf[BUF_SIZE];    pthread_t t_id;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;, argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    memset(&amp;serv_adr, 0, sizeof(serv_adr));    serv_adr.sin_family &#x3D; AF_INET;    serv_adr.sin_addr.s_addr &#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) printf(&quot;bind error&quot;);    if(listen(serv_sock,20)&#x3D;&#x3D;-1) printf(&quot;listen error&quot;);    while(1)    &#123;        clnt_adr_size&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_size);        printf(&quot;connection request:%s:%d\n&quot;,        inet_ntoa(clnt_adr.sin_addr),ntohs(clnt_adr.sin_port));        pthread_create(&amp;t_id,NULL,request_handler,&amp;clnt_sock);        pthread_detach(t_id);    &#125;    close(serv_sock);    return 0;&#125;void* request_handler(void* arg)&#123;    int clnt_sock&#x3D;*((int*)arg);    char req_line[SMALL_BUF];    FILE* clnt_read;    FILE* clnt_write;    char method[10];    char ct[15];    char file_name[30];    clnt_read&#x3D;fdopen(clnt_sock,&quot;r&quot;);    clnt_write&#x3D;fdopen(dup(clnt_sock),&quot;w&quot;);    fgets(req_line,SMALL_BUF,clnt_read);    if(strstr(req_line,&quot;HTTP&#x2F;&quot;)&#x3D;&#x3D;NULL)    &#123;        send_error(clnt_write);        fclose(clnt_read);        fclose(clnt_write);        &#x2F;&#x2F; return;    &#125;    strcpy(method,strtok(req_line,&quot; &#x2F;&quot;));    strcpy(file_name,strtok(NULL,&quot; &#x2F;&quot;));    strcpy(ct,content_type(file_name));    if(strcmp(method,&quot;GET&quot;)!&#x3D;0)    &#123;        send_error(clnt_write);        fclose(clnt_read);        fclose(clnt_write);        &#x2F;&#x2F; return;    &#125;    fclose(clnt_read);    send_data(clnt_write,ct,file_name);&#125;void send_data(FILE *fp,char *ct, char *file_name)&#123;    char protocol[]&#x3D;&quot;HTTP&#x2F;1.0 200 OK\r\n&quot;;    char server[]&#x3D;&quot;Server:Linux Web Server\r\n&quot;;    char cnt_len[]&#x3D;&quot;Content-length:2048\r\n&quot;;    char cnt_type[SMALL_BUF];    char buf[BUF_SIZE];    FILE *send_file;    sprintf(cnt_type,&quot;Content-type:%s\r\n\r\n&quot;,ct);    send_file&#x3D;fopen(file_name,&quot;r&quot;);    if(send_file&#x3D;&#x3D;NULL)    &#123;        send_error(fp);        return;    &#125;    fputs(protocol,fp);    fputs(server,fp);    fputs(cnt_len,fp);    fputs(cnt_type,fp);    while(fgets(buf,BUF_SIZE,send_file)!&#x3D;NULL)    &#123;        fputs(buf,fp);        fflush(fp);    &#125;&#125;char * content_type(char* file)&#123;    char extension[SMALL_BUF];    char file_name[SMALL_BUF];    strcpy(file_name,file);    strtok(file_name,&quot;.&quot;);    strcpy(extension,strtok(NULL,&quot;.&quot;));    if(!strcmp(extension,&quot;html&quot;)|| !strcmp(extension,&quot;htm&quot;))        return &quot;text&#x2F;html&quot;;    else        return &quot;text&#x2F;plain&quot;;&#125;void send_error(FILE *fp)&#123;    char protocol[]&#x3D;&quot;HTTP&#x2F;1.0 400 Bad Request\r\n&quot;;    char server[]&#x3D;&quot;Server:Linux Web Server\r\n&quot;;    char cnt_len[]&#x3D;&quot;Content_Length:2048\r\n&quot;;    char cnt_type[]&#x3D;&quot;Content-Type:text&#x2F;html\r\n\r\n&quot;;    char content[]&#x3D;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&quot;        &quot;&lt;body&gt;&lt;front size&#x3D;+5&lt;br&gt;发生错五！查看请求文件名和请求方式！&quot;        &quot;&lt;&#x2F;front&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;;        fputs(protocol,fp);        fputs(server,fp);        fputs(cnt_len,fp);        fputs(cnt_type,fp);        fflush(fp);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（四）</title>
      <link href="/2023/06/02/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/"/>
      <url>/2023/06/02/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</url>
      
        <content type="html"><![CDATA[<h2 id="10-多进程服务器端"><a href="#10-多进程服务器端" class="headerlink" title="10.多进程服务器端"></a>10.多进程服务器端</h2><h3 id="（3）基于多任务的并发服务器"><a href="#（3）基于多任务的并发服务器" class="headerlink" title="（3）基于多任务的并发服务器"></a>（3）基于多任务的并发服务器</h3><p><img src="https://s1.ax1x.com/2023/06/02/pCp99Cq.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char * message);void read_childproc(int sig);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    pid_t pid;    struct sigaction act;    socklen_t adr_sz;    char buf[BUF_SIZE];    int str_len,state;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    act.sa_handler&#x3D;read_childproc;    sigemptyset(&amp;act.sa_mask);    act.sa_flags&#x3D;0;    state&#x3D;sigaction(SIGCHLD, &amp;act, 0);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    while(1)    &#123;        adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             continue;        else             puts(&quot;new client connected...&quot;);        pid&#x3D;fork();        if(pid&#x3D;&#x3D;-1)         &#123;            close(clnt_sock);            continue;        &#125;                            if(pid&#x3D;&#x3D;0)        &#123;            close(serv_sock);            while((str_len&#x3D;read(clnt_sock,buf,BUF_SIZE))!&#x3D;0)                write(clnt_sock,buf,str_len);            close(clnt_sock);            puts(&quot;client disconnected&quot;);            return 0;        &#125;        else            close(clnt_sock);            &#125;        close(serv_sock);    return 0;&#125;   void read_childproc(int sig)&#123;    pid_t pid;    int status;    pid&#x3D;waitpid(-1,&amp;status,WNOHANG);    printf(&quot;removed proc id:%d\n&quot;,pid);&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）分割TCP的I-x2F-O程序"><a href="#（4）分割TCP的I-x2F-O程序" class="headerlink" title="（4）分割TCP的I&#x2F;O程序"></a>（4）分割TCP的I&#x2F;O程序</h3><p>客户端的父进程负责接收数据，额外创建的子进程负责发送数据。 分割后，不同进程分别负责输入和输出，这样，无论客户端是否从服务器端接收完数据都可以进行传输。</p><p><img src="https://s1.ax1x.com/2023/06/02/pCppzUs.png"></p><p>分割程序的另一个好处是，可以频繁交换数据的性能：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9C80.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char * message);void read_routine(int sock,char *buf);void write_routine(int sock,char *buf);int main(int argc,char *argv[])&#123;    int sock;    pid_t pid;    char buf[BUF_SIZE];    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);        if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)        write_routine(sock,buf);    else        read_routine(sock,buf);    close(sock);    return 0;    &#125;void read_routine(int sock,char *buf)&#123;    while(1)    &#123;        int str_len&#x3D;read(sock,buf,BUF_SIZE);            if(str_len&#x3D;&#x3D;0)            return;        buf[str_len]&#x3D;0;&#x2F;&#x2F;和‘&#x2F;0’有啥区别？一定要加这个吗        printf(&quot;message from server:%s\n&quot;,buf);    &#125;&#125;void write_routine(int sock,char *buf)&#123;    while(1)    &#123;        fgets(buf,BUF_SIZE,stdin);        if(!strcmp(buf,&quot;q\n&quot; )|| !strcmp(buf,&quot;Q\n&quot;))        &#123;            shutdown(sock,SHUT_WR);            return;        &#125;        write(sock,buf,strlen(buf));    &#125;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-进程间通信"><a href="#11-进程间通信" class="headerlink" title="11.进程间通信"></a>11.进程间通信</h2><h3 id="（1）通过管道实现进程间通信"><a href="#（1）通过管道实现进程间通信" class="headerlink" title="（1）通过管道实现进程间通信"></a>（1）通过管道实现进程间通信</h3><h4 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int pipe(int filedes[2]);&#x2F;&#x2F;成0，败1&#x2F;&#x2F;filedes[0]通过管道接受数据时使用的文件描述符，即管道出口&#x2F;&#x2F;filedes[1]通过管道传输数据时使用的文件描述符，即管道入口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口的1个文件描述符传递给子进程（调用fork函数）。</p><p>pipe1.c:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds[2];    char str[]&#x3D;&quot;hello&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds[1],str,sizeof(str));    &#125;    else&#123;        read(fds[0],buf,BUF_SIZE);        puts(buf);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图示：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCppxEj.png"></p><h4 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h4><p><img src="https://s1.ax1x.com/2023/06/02/pCppjbQ.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds[2];    char str1[]&#x3D;&quot;hello&quot;;    char str2[]&#x3D;&quot;thank you for your message&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds[1],str1,sizeof(str1));        sleep(2);        read(fds[0],buf,BUF_SIZE);        printf(&quot;child proc output:%s\n&quot;,buf);    &#125;    else    &#123;        read(fds[0],buf,BUF_SIZE);        printf(&quot;parent proc output:%s\n&quot;,buf);        write(fds[1],str2,sizeof(str2));        sleep(3);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>升级成两个管道，各自负责不同的数据流动：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9S5n.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds1[2],fds2[2];    char str1[]&#x3D;&quot;hello&quot;;    char str2[]&#x3D;&quot;thank you for your message&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds1),pipe(fds2);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds1[1],str1,sizeof(str1));        read(fds2[0],buf,BUF_SIZE);        printf(&quot;child proc output:%s\n&quot;,buf);    &#125;    else    &#123;        read(fds1[0],buf,BUF_SIZE);        printf(&quot;parent proc output:%s\n&quot;,buf);        write(fds2[1],str2,sizeof(str2));        sleep(3);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-运用进程间通信"><a href="#2-运用进程间通信" class="headerlink" title="(2)运用进程间通信"></a>(2)运用进程间通信</h3><p><strong>保存消息的回声服务器端</strong> 将回声客户端传输的字符串按序保存到文件中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 100&#x2F;&#x2F;懒得写报错函数了void read_childproc(int sig);int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int fds[2];    pid_t pid;    struct sigaction act;    socklen_t adr_sz;    int str_len,state;    char buf[BUF_SIZE];    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    act.sa_handler&#x3D;read_childproc;    sigemptyset(&amp;act.sa_mask);    act.sa_flags&#x3D;0;    state&#x3D;sigaction(SIGCHLD,&amp;act,0);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_sock));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));    listen(serv_sock,5);    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        FILE *fp&#x3D;fopen(&quot;echomsg.txt&quot;,&quot;wt&quot;);        char msgbuf[BUF_SIZE];        int len;        for(int i&#x3D;0;i&lt;10;++i)        &#123;            len&#x3D;read(fds[0],msgbuf,BUF_SIZE);            fwrite((void*)msgbuf,1,len,fp);        &#125;        fclose(fp);        return 0;    &#125;    while(1)    &#123;        adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)            continue;        else            puts(&quot;new client connection&quot;);        pid&#x3D;fork();        if(pid&#x3D;&#x3D;0)        &#123;            close(serv_sock);            while((str_len&#x3D;read(clnt_sock,buf,BUF_SIZE))!&#x3D;0)            &#123;                write(clnt_sock,buf,str_len);                write(fds[1],buf,str_len);            &#125;            close(clnt_sock);            puts(&quot;clients connected&quot;);            return 0;        &#125;        else             close(clnt_sock);    &#125;    close(serv_sock);    return 0;&#125;void read_childproc(int sig)&#123;    pid_t pid;    int status;    pid&#x3D;waitpid(-1,&amp;status,WNOHANG);    printf(&quot;removed proc id:%d\n&quot;,pid);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-I-x2F-O复用"><a href="#12-I-x2F-O复用" class="headerlink" title="12.I&#x2F;O复用"></a>12.I&#x2F;O复用</h2><h3 id="（1）基于I-x2F-O复用的服务器端"><a href="#（1）基于I-x2F-O复用的服务器端" class="headerlink" title="（1）基于I&#x2F;O复用的服务器端"></a>（1）基于I&#x2F;O复用的服务器端</h3><p>多进程服务器模型：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9P2V.png"></p><p>I&#x2F;O复用服务器模型：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9ivT.png"></p><h3 id="（2）理解select函数并实现服务器端"><a href="#（2）理解select函数并实现服务器端" class="headerlink" title="（2）理解select函数并实现服务器端"></a>（2）理解select函数并实现服务器端</h3><p>select函数调用方法和顺序：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9kKU.png"></p><h4 id="设置文件描述符"><a href="#设置文件描述符" class="headerlink" title="设置文件描述符"></a>设置文件描述符</h4><p>fd_set变量中注册和更改值由以下宏完成：<br><img src="https://s1.ax1x.com/2023/06/02/pCp9ZVJ.png"></p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9Eb4.png"></p><h4 id="设置监视范围与超时"><a href="#设置监视范围与超时" class="headerlink" title="设置监视范围与超时"></a>设置监视范围与超时</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;select.h&gt;#include&lt;sys&#x2F;time.h&gt;int select(    int maxfd,fd_set * readset,fd_set * writeset,fd_set * exceptset,const struct timeval * timeout);&#x2F;&#x2F;成返回大于0的值，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/pCp9ea9.png"></p><p>timeval结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct timeval&#123;    long tv_sec;    long tv_usec;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="select函数调用示例"><a href="#select函数调用示例" class="headerlink" title="select函数调用示例"></a>select函数调用示例</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;time.h&gt;#include&lt;sys&#x2F;select.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[])&#123;    fd_set reads,temps;    int result,str_len;    char buf[BUF_SIZE];    struct timeval timeout;    FD_ZERO(&amp;reads);    FD_SET(0,&amp;reads);&#x2F;&#x2F;0 is standard input(console);    while(1)    &#123;        temps&#x3D;reads;        timeout.tv_sec&#x3D;5;        timeout.tv_usec&#x3D;0;        result&#x3D;select(1,&amp;temps,0,0,&amp;timeout);        if(result&#x3D;&#x3D;-1)        &#123;            puts(&quot;select() error&quot;);            break;        &#125;        else if(result&#x3D;&#x3D;0)        &#123;            puts(&quot;timeout&quot;);        &#125;        else        &#123;            if(FD_ISSET(0,&amp;temps))            &#123;                str_len&#x3D;read(0,buf,BUF_SIZE);                buf[str_len]&#x3D;0;                printf(&quot;message from console: %s\n&quot;,buf);            &#125;                    &#125;    &#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现I-x2F-O复用服务器端"><a href="#实现I-x2F-O复用服务器端" class="headerlink" title="实现I&#x2F;O复用服务器端"></a>实现I&#x2F;O复用服务器端</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;time.h&gt;#include&lt;sys&#x2F;select.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 100&#x2F;&#x2F;报错函数懒得写了int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    struct timeval timeout;    fd_set reads,cpy_reads;    socklen_t adr_sz;    int fd_max,str_len,fd_num;    char buf[BUF_SIZE];    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));    listen(serv_sock,5);    FD_ZERO(&amp;reads);    FD_SET(serv_sock,&amp;reads);    fd_max&#x3D;serv_sock;    while(1)    &#123;        cpy_reads&#x3D;reads;        timeout.tv_sec&#x3D;5;        timeout.tv_usec&#x3D;5000;        if((fd_num&#x3D;select(fd_max+1,&amp;cpy_reads,0,0,&amp;timeout))&#x3D;&#x3D;-1)            break;        if(fd_num&#x3D;&#x3D;0)        &#123;            continue;        &#125;        for(int i&#x3D;0; i&lt;fd_max+1; ++i)        &#123;            if(FD_ISSET(i,&amp;cpy_reads))            &#123;                if(i&#x3D;&#x3D;serv_sock)&#x2F;&#x2F;connection request                &#123;                    adr_sz&#x3D;sizeof(clnt_adr);                    clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                    FD_SET(clnt_sock,&amp;reads);                    if(fd_max&lt;clnt_sock)                        fd_max&#x3D;clnt_sock;                    printf(&quot;connected client:%d\n&quot;,clnt_sock);                &#125;                else&#x2F;&#x2F;read message                &#123;                    str_len&#x3D;read(i,buf,BUF_SIZE);                    if(str_len&#x3D;&#x3D;0)&#x2F;&#x2F;close request                    &#123;                                                FD_CLR(i,&amp;reads);                        close(i);                        printf(&quot;closed client:%d\n&quot;,i);                    &#125;                    else                    &#123;                        write(i,buf,str_len);&#x2F;&#x2F;echo                    &#125;                                                           &#125;            &#125;        &#125;    &#125;    close(serv_sock);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（三）</title>
      <link href="/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<h2 id="9-套接字的多种可选项"><a href="#9-套接字的多种可选项" class="headerlink" title="9.套接字的多种可选项"></a>9.套接字的多种可选项</h2><h3 id="（1）套接字的多种可选项："><a href="#（1）套接字的多种可选项：" class="headerlink" title="（1）套接字的多种可选项："></a>（1）套接字的多种可选项：</h3><p><img src="https://s1.ax1x.com/2023/06/02/p9zh7Gt.png"><br><img src="https://s1.ax1x.com/2023/06/02/p9z4pin.png"></p><h3 id="（2）getsocket-amp-setsocket"><a href="#（2）getsocket-amp-setsocket" class="headerlink" title="（2）getsocket &amp; setsocket"></a>（2）getsocket &amp; setsocket</h3><p>可选项的的读取和设置由以下两个函数完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int getsockopt(int sock,int level,int optname,void *optval,socklen_t *optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhIIA.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int setsockopt(int sock,int level,int optname,const void *optval,socklen_t optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhHRP.png"></p><h4 id="用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）："><a href="#用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）：" class="headerlink" title="用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）："></a>用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;socket.h&gt;void error_handling(char *message);int main(int argc, char *argv[])&#123;    int tcp_sock,udp_sock;    int sock_type;    socklen_t optlen;    int state;    optlen&#x3D;sizeof(sock_type);    tcp_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    udp_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    printf(&quot;SOCK_STREAM:%d\n&quot;,SOCK_STREAM);    printf(&quot;SOCK_DGRAM:%d\n&quot;,SOCK_DGRAM);    state&#x3D;getsockopt(tcp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type one:%d\n&quot;,sock_type);        state&#x3D;getsockopt(udp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type two:%d\n&quot;,sock_type);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhTPI.png"></p><h3 id="（3）SO-SNDBUF-amp-SO-RCVBUF"><a href="#（3）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="（3）SO_SNDBUF &amp; SO_RCVBUF"></a>（3）SO_SNDBUF &amp; SO_RCVBUF</h3><p> 前者是输入缓冲大小相关可选项，后者输出的，这两个可选项既可以读取当前I&#x2F;O缓冲大小，也可以进行更改。（代码和上面差不多）</p><h3 id="（4）SO-REUSEADDR"><a href="#（4）SO-REUSEADDR" class="headerlink" title="（4）SO_REUSEADDR"></a>（4）SO_REUSEADDR</h3><p> 假设主机A的四次握手过程中最后的数据丢失，则主机B会认为A未能收到自己发送的FIN消息，因此重传。此时收到FIN消息的主机A将重启Time_wait计时器。所以网络状况不理想的话，Time_wait状态将持续。</p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhbxf.png"></p><p>解决方法就是在套接字的可选项中更改SO_REUSEADDR的状态，将默认值0改为:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">optlen&#x3D;sizeof(option);option&#x3D;TRUE;setsockopt(serv_sock,SOL_SOCKET,SO_REUSEADDR,(void*)&amp;option,optlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（5）TCP-NODELAY"><a href="#（5）TCP-NODELAY" class="headerlink" title="（5）TCP_NODELAY"></a>（5）TCP_NODELAY</h3><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p><img src="https://s1.ax1x.com/2023/06/02/p9zhLM8.png"></p><p>但传输大文件数据时即使不使用该算法也会在装满缓冲时传输数据包，这样不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。</p><h4 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">int opt_val&#x3D;1;setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(void *)&amp;opt_val,sizeof(opt_val));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="10-多进程服务器端"><a href="#10-多进程服务器端" class="headerlink" title="10.多进程服务器端"></a>10.多进程服务器端</h2><h3 id="（1）进程"><a href="#（1）进程" class="headerlink" title="（1）进程"></a>（1）进程</h3><h4 id="并发服务器的实现方法"><a href="#并发服务器的实现方法" class="headerlink" title="并发服务器的实现方法"></a>并发服务器的实现方法</h4><p>如下图所示：（多进程服务器Windows平台不支持）<br><img src="https://s1.ax1x.com/2023/06/02/p9zhxaj.png"></p><h4 id="调用fork函数创建进程"><a href="#调用fork函数创建进程" class="headerlink" title="调用fork函数创建进程"></a>调用fork函数创建进程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;pid_t fork(void);&#x2F;&#x2F;成进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过同一个进程复制相同的内存空间，之后的程序要根据返回值加以区分：</p><p>父进程：fork函数返回子进程id</p><p>子进程：fork函数返回0</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>为了摧毁子进程，父进程应主动请求获取子进程的返回值，<strong>方法其一</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t wait(int* statloc);&#x2F;&#x2F;成子进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用此函数如果有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值&#x2F;main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离：</p><p>WIFEXITED:子进程正常终止时返回true</p><p>WEXITSTATUS：返回子进程的返回值</p><p>向wait函数传递变量status的地址时，调用wait函数后应编写如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(WIFEXITED(status))&#123;    puts(&quot;normal termination&quot;);    printf(&quot;child pass num:%d&quot;,WEXITSTATUS(status));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用wait函数时，如果没有已终止的子进程，那么程序将阻塞直到有子进程终止，谨慎使用。</p><p><strong>方法其二</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t waitpid(pid_t pid,int *statloc,int options);&#x2F;&#x2F;成返回终止的子进程id或0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhOsS.png"></p><h3 id="（2）信号处理"><a href="#（2）信号处理" class="headerlink" title="（2）信号处理"></a>（2）信号处理</h3><p>进程发现自己的子进程结束时，请求操作系统调用特定函数（信号注册函数）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;void (*signal(int signo,void(*func)(int)))(int);&#x2F;&#x2F;为了在产生信号时调用，返回之前注册的函数指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhXqg.png"></p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhvZQ.png"></p><h4 id="编写signal函数"><a href="#编写signal函数" class="headerlink" title="编写signal函数"></a>编写signal函数</h4><p><strong>请求</strong> 已到通过alarm函数注册的时间，调用timeout函数；输入CTRL+C时调用keycontrol函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void timeout(int sig)&#123;    if(sig&#x3D;&#x3D;SIGALRM)        puts(&quot;time out&quot;);    alarm(2);&#125;void keycontrol(int sig)&#123;    if(sig&#x3D;&#x3D;SIGINT)        puts(&quot;CTRL+C pressed&quot;);&#125;int main(int argc,char *argv[])&#123;    signal(SIGALRM,timeout);    signal(SIGINT,keycontrol);    alarm(2);    for(int i&#x3D;0;i&lt;3;++i)    &#123;        puts(&quot;wait....&quot;);        sleep(100);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhzIs.png"></p><h4 id="利用sigaction函数进行信号处理-更稳定"><a href="#利用sigaction函数进行信号处理-更稳定" class="headerlink" title="利用sigaction函数进行信号处理(更稳定)"></a>利用sigaction函数进行信号处理(更稳定)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;int sigaction(int signo,const struct sigaction *act,struct sigaction * oldact);&#x2F;&#x2F;成0，败1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9z49Gq.png"></p><p>声明并初始化sigaction结构体变量以调用上述函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sigaction&#123;    void (*sa_handler)(int);    sigset_t sa_mask;    int sa_flags;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（二）</title>
      <link href="/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h2 id="6-基于UDP的服务器端-x2F-客户端"><a href="#6-基于UDP的服务器端-x2F-客户端" class="headerlink" title="6.基于UDP的服务器端&#x2F;客户端"></a>6.基于UDP的服务器端&#x2F;客户端</h2><h3 id="（1）基于UDP的数据I-x2F-O函数"><a href="#（1）基于UDP的数据I-x2F-O函数" class="headerlink" title="（1）基于UDP的数据I&#x2F;O函数"></a>（1）基于UDP的数据I&#x2F;O函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t sendto(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *to,socklen_t addrlen);&#x2F;&#x2F;成功时返回传输的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYf1K.png"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t recvfrom(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t addrlen);&#x2F;&#x2F;成功接受的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYIne.png"></p><h3 id="2-基于UDP的回声服务器端-x2F-客户端"><a href="#2-基于UDP的回声服务器端-x2F-客户端" class="headerlink" title="(2)基于UDP的回声服务器端&#x2F;客户端"></a>(2)基于UDP的回声服务器端&#x2F;客户端</h3><p>sendto函数自动分配IP和端口号，所以UDP客户端中通常无需额外的地址分配过程</p><p>服务器端：uechos.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int serv_sock;    char message[BUF_SIZE];    int str_len;    socklen_t clnt_adr_sz;    struct sockaddr_in serv_adr,clnt_adr;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(serv_sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;binding error&quot;);    &#125;    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        str_len&#x3D;recvfrom(serv_sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        sendto(serv_sock,message,str_len,0,(struct sockaddr*)&amp;clnt_adr,clnt_adr_sz);    &#125;    close(serv_sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：uechoc.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    socklen_t adr_sz;    struct sockaddr_in serv_adr,from_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    while(1)    &#123;        fputs(&quot;insert ,message(q to quit):&quot;,stdout);        fgets(message,sizeof(message),stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;        sendto(sock,message,strlen(message),0,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));        adr_sz&#x3D;sizeof(from_adr);        str_len&#x3D;recvfrom(sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;from_adr,&amp;adr_sz);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server:%s&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYHAA.png"></p><h3 id="（3）已连接UDP套接字与未连接UDP套接字"><a href="#（3）已连接UDP套接字与未连接UDP套接字" class="headerlink" title="（3）已连接UDP套接字与未连接UDP套接字"></a>（3）已连接UDP套接字与未连接UDP套接字</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9xYo0H.png"></p><p>每次调用sendto函数重复上述过程，每次都变更目标地址，因此可以重复利用同一套UDP套接字向不同目标传输数据。这种未注册目标地点信息的套接字称为未连接套接字。</p><p>创建已连接UDP套接字：</p><pre class="line-numbers language-none"><code class="language-none">sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);memset(&amp;adr,0,sizeof(adr));adr.sin_family&#x3D;AF_INET;adr.sin_addr.s_addr&#x3D;...adr.sin_port&#x3D;...connect(sock,(struct sockaddr*)&amp;adr,sizeof(adr));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后与TCP套接字一样，每次调用sendto函数时只需传输数据。因为已经指定了收发对象，所以还可以使用write,read函数进行通信。</p><h2 id="7-优雅地断开套接字的连接"><a href="#7-优雅地断开套接字的连接" class="headerlink" title="7.优雅地断开套接字的连接"></a>7.优雅地断开套接字的连接</h2><h3 id="1-shutdown函数"><a href="#1-shutdown函数" class="headerlink" title="(1)shutdown函数"></a>(1)shutdown函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;int shutdown(int sock,int howto);&#x2F;&#x2F;成0败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个值：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xY4XD.png"></p><h3 id="2-半关闭"><a href="#2-半关闭" class="headerlink" title="(2)半关闭"></a>(2)半关闭</h3><p>调用close函数的同时关闭I&#x2F;O流，这样也会向对方发送EOF，但此时无法接受对方传输的数据。调用shutdown函数只关闭输出流，这样既可以发送EOF，又保留了输入流，可以接受对方数据。</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYO9P.png"></p><h2 id="8-域名及网络地址"><a href="#8-域名及网络地址" class="headerlink" title="8.域名及网络地址"></a>8.域名及网络地址</h2><h3 id="（1）域名系统"><a href="#（1）域名系统" class="headerlink" title="（1）域名系统"></a>（1）域名系统</h3><h4 id="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"><a href="#DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。" class="headerlink" title="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"></a>DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。</h4><p>域名：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYT7d.png"></p><p>DNS获取IP地址信息：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYqht.png"></p><h3 id="（2）利用域名获取IP地址："><a href="#（2）利用域名获取IP地址：" class="headerlink" title="（2）利用域名获取IP地址："></a>（2）利用域名获取IP地址：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyname(const char * hostname);&#x2F;&#x2F;成hostent结构体地址，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hostent结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hostent&#123;    char * h_name;&#x2F;&#x2F;官方域名    char ** h_aliases;&#x2F;&#x2F;alias list,同一个IP可以绑定多个域名    int h_addrtype;&#x2F;&#x2F;host address type    int h_length;&#x2F;&#x2F;保存IP地址长度    char ** h_addr_list;&#x2F;&#x2F;最重要的成员，通过此变量以整数形式保存域名对应的IP地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYbtI.png"></p><h3 id="（3）利用IP地址获取域名："><a href="#（3）利用IP地址获取域名：" class="headerlink" title="（3）利用IP地址获取域名："></a>（3）利用IP地址获取域名：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyaddr(const char *addr,socklen_t len,int family);&#x2F;&#x2F;成hostent结构体地址值，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（一）</title>
      <link href="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：该内容基于Linux平台，且笔记比较精简，省略了笔者大量思考内容，但有助于知识点复盘。</p><h2 id="1-网络编程与套接字"><a href="#1-网络编程与套接字" class="headerlink" title="1.网络编程与套接字"></a>1.网络编程与套接字</h2><h3 id="（1）调用socket函数创建套接字："><a href="#（1）调用socket函数创建套接字：" class="headerlink" title="（1）调用socket函数创建套接字："></a>（1）调用socket函数创建套接字：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（2）调用-bind-函数分配IP地址和端口号："><a href="#（2）调用-bind-函数分配IP地址和端口号：" class="headerlink" title="（2）调用 bind 函数分配IP地址和端口号："></a>（2）调用 bind 函数分配IP地址和端口号：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket.h&gt; int bind(int sockfd, strcuct sockaddr *myaddr, socklen_t addrlen);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）调用listen函数转为可接受请求状态："><a href="#（3）调用listen函数转为可接受请求状态：" class="headerlink" title="（3）调用listen函数转为可接受请求状态："></a>（3）调用listen函数转为可接受请求状态：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int listen(int sockfd,int backlog);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）调用accept函数受理连接请求："><a href="#（4）调用accept函数受理连接请求：" class="headerlink" title="（4）调用accept函数受理连接请求："></a>（4）调用accept函数受理连接请求：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-基于Linux的文件操作"><a href="#2-基于Linux的文件操作" class="headerlink" title="2.基于Linux的文件操作"></a>2.基于Linux的文件操作</h2><h3 id="（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）"><a href="#（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）" class="headerlink" title="（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）"></a>（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）</h3><p>分配给标准输入输出及标准错误的文件描述符：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsq29.png"></p><h3 id="（2）打开文件"><a href="#（2）打开文件" class="headerlink" title="（2）打开文件"></a>（2）打开文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;fcntl.h&gt;int open(const char *path,int flag);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag可能的值与含义：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsLvR.png"></p><h3 id="（3）关闭文件"><a href="#（3）关闭文件" class="headerlink" title="（3）关闭文件"></a>（3）关闭文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int close(int fd);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）将数据写入文件"><a href="#（4）将数据写入文件" class="headerlink" title="（4）将数据写入文件"></a>（4）将数据写入文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）读取文件中的数据"><a href="#（4）读取文件中的数据" class="headerlink" title="（4）读取文件中的数据"></a>（4）读取文件中的数据</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数（但遇到文件结尾则返回0），失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-套接字类型与协议设置"><a href="#3-套接字类型与协议设置" class="headerlink" title="3.套接字类型与协议设置"></a>3.套接字类型与协议设置</h2><h3 id="（1）协议族"><a href="#（1）协议族" class="headerlink" title="（1）协议族"></a>（1）协议族</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9vsb8J.png"></p><p>一般只用PF_INET(IPv4互联网协议族)</p><h3 id="（2）套接字类型"><a href="#（2）套接字类型" class="headerlink" title="（2）套接字类型"></a>（2）套接字类型</h3><p>SOCK_STREAM(面向连接):</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsHC4.png"></p><p>SOCK_SGRAM（面向消息）:</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsT5F.png"></p><p>*第三个参数一般为0（数据传输方式相同， 但协议不同。 此时需要通过第3个参数具体指定协议信息）</p><h2 id="4-地址族与数据序列"><a href="#4-地址族与数据序列" class="headerlink" title="4.地址族与数据序列"></a>4.地址族与数据序列</h2><h3 id="（1）表示IPv4地址的结构体"><a href="#（1）表示IPv4地址的结构体" class="headerlink" title="（1）表示IPv4地址的结构体"></a>（1）表示IPv4地址的结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">stuct sockaddr_in &#123;    sa_family_t sin_family sin_family;&#x2F;&#x2F;地址族（Address Family）    uint16_t         sin_port;&#x2F;&#x2F;16位TCP&#x2F;UDP端口号    struct in_addr   sin_addr;&#x2F;&#x2F;32位IP地址    char             sin_zero[0];&#x2F;&#x2F;不使用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct in_addr&#123;    in_addr_t    s_addr;&#x2F;&#x2F;32位IPv4地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*POSIX中定义的数据类型（用于提高扩展性）</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsjDx.png"></p><h3 id="（2）结构体sockaddr-in成员分析"><a href="#（2）结构体sockaddr-in成员分析" class="headerlink" title="（2）结构体sockaddr_in成员分析"></a>（2）结构体sockaddr_in成员分析</h3><p>sin_family：地址族，一般为AF_INET</p><p>sin_port：保存16位端口</p><p>sin_addr：保存32位IP地址信息</p><h3 id="（3）网络字节序"><a href="#（3）网络字节序" class="headerlink" title="（3）网络字节序"></a>（3）网络字节序</h3><p>网络字节序位为大端模式，主机字节序为小端模式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned short htons(unsigned short); unsigned short ntohs(unsîgned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>h代表主机字节序，n代表网络字节序</p><h3 id="（4）网络地址的初始化与分配"><a href="#（4）网络地址的初始化与分配" class="headerlink" title="（4）网络地址的初始化与分配"></a>（4）网络地址的初始化与分配</h3><p>将字符串形式的IP地址转换成32位整数型数据（此类型在转换类型的同时进行网络字节序转换）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int_addr_t inet_addr(const char* string);&#x2F;&#x2F;成功时返回32位大端序整数型值，失败时返回INADDR_NODE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_aton(const char* string,struct in_addr *addr);&#x2F;&#x2F;成功时返回1，失败时返回0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>*后者传递in_addr结构体变量地址值，函数会自动把结果填入该结构体得到变量，所以使用频率更高。</p><p>反过来转换：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_ntoa(struct in_addr adr);&#x2F;&#x2F;成功时返回转换的字符串地址值，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建套接字常见的网络地址信息初始化方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sockaddr_in addr; char * serv_ip &#x3D; &quot;211.117.168.13&quot;;     &#x2F;&#x2F;声明 IP 地址字符串char * serv_port &#x3D; &quot;9190&quot;;           &#x2F;&#x2F;声明端口号字符串memset(&amp;addr, 0 , sizeof(addr));     &#x2F;&#x2F;结构体addr的所有成员初始化为0addr.sin_family &#x3D; AF_INET;           &#x2F;&#x2F; 指定地址族addr.sin_addr.s_addr &#x3D; inet_addr(serv_ip);  &#x2F;&#x2F;基于字符串IP地址初始化addr.sin_port &#x3D; htons(atoi(serv_port));     &#x2F;&#x2F;基于字符串的端口号初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次创建服务器端套接字都要输入 地址会有些繁琐，此时可如下初始化地址信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sckaddr_in addr;char * serv_port &#x3D;&quot;9190&quot;;memset(&amp;addr,0,szieof(addr));addr.sin_family&#x3D;AF_INET;addr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);addr.sin_port&#x3D;htons(atoi(serv_port));&#x2F;&#x2F;利用常数可自动获取服务器端的计算机IP，不用手动输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-基于TCP的服务器端-x2F-客户端"><a href="#5-基于TCP的服务器端-x2F-客户端" class="headerlink" title="5.基于TCP的服务器端&#x2F;客户端"></a>5.基于TCP的服务器端&#x2F;客户端</h2><h3 id="（1）TCP-服务器端-x2F-客户端的函数调用关系"><a href="#（1）TCP-服务器端-x2F-客户端的函数调用关系" class="headerlink" title="（1）TCP 服务器端&#x2F;客户端的函数调用关系"></a>（1）TCP 服务器端&#x2F;客户端的函数调用关系</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9vyCPe.png"></p><h3 id="（2）迭代回声服务器-x2F-客户端"><a href="#（2）迭代回声服务器-x2F-客户端" class="headerlink" title="（2）迭代回声服务器&#x2F;客户端"></a>（2）迭代回声服务器&#x2F;客户端</h3><p>程序基本运行方式：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyp5D.png"><br>服务器端(echo_sever.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;++i)    &#123;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             error_handling(&quot;accept() error&quot;);        else            printf(&quot;connect client %d\n&quot;,i+1);        while((str_len&#x3D;read(clnt_sock,message,BUF_SIZE))!&#x3D;0)            write(clnt_sock,message,str_len);        close(clnt_sock);        return 0;    &#125;    close(serv_sock);    return 0;&#125;   void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端(echo_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    while(1)    &#123;        fputs(&quot;input message(Q to quit):&quot;,stdout);        fgets(message,BUF_SIZE,stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;                write(sock,message,strlen(message));        str_len&#x3D;read(sock,message,BUF_SIZE-1);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server %s\n&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回声客户端存在的问题：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyi2d.png"></p><p>修改迭代部分：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyAKI.png"></p><h3 id="（3）计算器服务器端-x2F-客户端示例"><a href="#（3）计算器服务器端-x2F-客户端示例" class="headerlink" title="（3）计算器服务器端&#x2F;客户端示例"></a>（3）计算器服务器端&#x2F;客户端示例</h3><p>客户端设计如下应用层协议：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyP8H.png"></p><p>客户端(op_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define RLT_SIZE 4#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int main(int argc,char *argv[])&#123;    int sock;    char opmsg[BUF_SIZE];    int result,opnd_cnt;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;usage:%s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)        error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error&quot;);    else       fputs(&quot;operand count:&quot;,stdout);       scanf(&quot;%d&quot;,&amp;opnd_cnt);       opmsg[0]&#x3D;(char)opnd_cnt;       for(int i&#x3D;0;i&lt;opnd_cnt;++i)       &#123;        printf(&quot;operand %d:&quot;,i+1);        scanf(&quot;%d&quot;,(int*)&amp;opmsg[i*OPSZ+1]);       &#125;       fgetc(stdin);       fputs(&quot;operator:&quot;,stdout);       scanf(&quot;%c&quot;,&amp;opmsg[opnd_cnt*OPSZ+1]);       write(sock,opmsg,opnd_cnt*OPSZ+2);       read(sock,&amp;result,RLT_SIZE);       printf(&quot;operation result:%d\n&quot;,result);       close(sock);       return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端(op_server.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int calculate(int opnum,int opnds[],char oprator);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char opinfo[BUF_SIZE];    int result,opnd_cnt;    int recv_cnt,recv_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc !&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    if(serv_sock&#x3D;&#x3D;-1)        error_handling(&quot;socket error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1)        error_handling(&quot;listen error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;i++)    &#123;        opnd_cnt&#x3D;0;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr *)&amp;clnt_adr,&amp;clnt_adr_sz);        read(clnt_sock,&amp;opnd_cnt,1);        recv_len&#x3D;0;        while((opnd_cnt*OPSZ+1)&gt;recv_len)        &#123;            recv_cnt&#x3D;read(clnt_sock,&amp;opinfo[recv_len],BUF_SIZE-1);            recv_len+&#x3D;recv_cnt;        &#125;        result&#x3D;calculate(opnd_cnt,(int*)opinfo,opinfo[recv_len-1]);        write(clnt_sock,(char*)&amp;result,sizeof(result));        close(clnt_sock);                &#125;    close(serv_sock);    return 0;&#125;int calculate(int opnum,int opnds[],char op)&#123;    int result&#x3D;opnds[0];    switch(op)    &#123;        case &#39;+&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result+&#x3D;opnds[i];            break;        case &#39;-&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result-&#x3D;opnds[i];            break;        case &#39;*&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result*&#x3D;opnds[i];            break;        case &#39;&#x2F;&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result&#x2F;&#x3D;opnds[i];            break;    &#125;    return result;;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）TCP内部工作原理"><a href="#（4）TCP内部工作原理" class="headerlink" title="（4）TCP内部工作原理"></a>（4）TCP内部工作原理</h3><p>a.与对方套接字的连接（三次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyFxA.png"></p><p>套接字是以全双工（Full-duplex）方式工作的，可以双向传递数据。</p><p>b.与对方主机的数据交换：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyErt.png"></p><p>有超时重传机制</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgLFK.png"></p><p>c.断开与套接字的连接（四次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgfWF.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
