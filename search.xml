<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP/IP网络编程（二）</title>
      <link href="/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<p>前言：本章学习有关UDP的特点以及网络编程（Linux平台）</p><h2 id="6-基于UDP的服务器端-x2F-客户端"><a href="#6-基于UDP的服务器端-x2F-客户端" class="headerlink" title="6.基于UDP的服务器端&#x2F;客户端"></a>6.基于UDP的服务器端&#x2F;客户端</h2><h3 id="（1）基于UDP的数据I-x2F-O函数"><a href="#（1）基于UDP的数据I-x2F-O函数" class="headerlink" title="（1）基于UDP的数据I&#x2F;O函数"></a>（1）基于UDP的数据I&#x2F;O函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t sendto(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *to,socklen_t addrlen);&#x2F;&#x2F;成功时返回传输的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYf1K.png"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t recvfrom(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t addrlen);&#x2F;&#x2F;成功接受的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYIne.png"></p><h3 id="2-基于UDP的回声服务器端-x2F-客户端"><a href="#2-基于UDP的回声服务器端-x2F-客户端" class="headerlink" title="(2)基于UDP的回声服务器端&#x2F;客户端"></a>(2)基于UDP的回声服务器端&#x2F;客户端</h3><p>sendto函数自动分配IP和端口号，所以UDP客户端中通常无需额外的地址分配过程</p><p>服务器端：uechos.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int serv_sock;    char message[BUF_SIZE];    int str_len;    socklen_t clnt_adr_sz;    struct sockaddr_in serv_adr,clnt_adr;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(serv_sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;binding error&quot;);    &#125;    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        str_len&#x3D;recvfrom(serv_sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        sendto(serv_sock,message,str_len,0,(struct sockaddr*)&amp;clnt_adr,clnt_adr_sz);    &#125;    close(serv_sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：uechoc.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    socklen_t adr_sz;    struct sockaddr_in serv_adr,from_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    while(1)    &#123;        fputs(&quot;insert ,message(q to quit):&quot;,stdout);        fgets(message,sizeof(message),stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;        sendto(sock,message,strlen(message),0,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));        adr_sz&#x3D;sizeof(from_adr);        str_len&#x3D;recvfrom(sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;from_adr,&amp;adr_sz);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server:%s&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYHAA.png"></p><h3 id="（3）已连接UDP套接字与未连接UDP套接字"><a href="#（3）已连接UDP套接字与未连接UDP套接字" class="headerlink" title="（3）已连接UDP套接字与未连接UDP套接字"></a>（3）已连接UDP套接字与未连接UDP套接字</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9xYo0H.png"></p><p>每次调用sendto函数重复上述过程，每次都变更目标地址，因此可以重复利用同一套UDP套接字向不同目标传输数据。这种未注册目标地点信息的套接字称为未连接套接字。</p><p>创建已连接UDP套接字：</p><pre class="line-numbers language-none"><code class="language-none">sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);memset(&amp;adr,0,sizeof(adr));adr.sin_family&#x3D;AF_INET;adr.sin_addr.s_addr&#x3D;...adr.sin_port&#x3D;...connect(sock,(struct sockaddr*)&amp;adr,sizeof(adr));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后与TCP套接字一样，每次调用sendto函数时只需传输数据。因为已经指定了收发对象，所以还可以使用write,read函数进行通信。</p><h2 id="7-优雅地断开套接字的连接"><a href="#7-优雅地断开套接字的连接" class="headerlink" title="7.优雅地断开套接字的连接"></a>7.优雅地断开套接字的连接</h2><h3 id="1-shutdown函数"><a href="#1-shutdown函数" class="headerlink" title="(1)shutdown函数"></a>(1)shutdown函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;int shutdown(int sock,int howto);&#x2F;&#x2F;成0败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个值：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xY4XD.png"></p><h3 id="2-半关闭"><a href="#2-半关闭" class="headerlink" title="(2)半关闭"></a>(2)半关闭</h3><p>调用close函数的同时关闭I&#x2F;O流，这样也会向对方发送EOF，但此时无法接受对方传输的数据。调用shutdown函数只关闭输出流，这样既可以发送EOF，又保留了输入流，可以接受对方数据。</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYO9P.png"></p><h2 id="8-域名及网络地址"><a href="#8-域名及网络地址" class="headerlink" title="8.域名及网络地址"></a>8.域名及网络地址</h2><h3 id="（1）域名系统"><a href="#（1）域名系统" class="headerlink" title="（1）域名系统"></a>（1）域名系统</h3><h4 id="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"><a href="#DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。" class="headerlink" title="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"></a>DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。</h4><p>域名：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYT7d.png"></p><p>DNS获取IP地址信息：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYqht.png"></p><h3 id="（2）利用域名获取IP地址："><a href="#（2）利用域名获取IP地址：" class="headerlink" title="（2）利用域名获取IP地址："></a>（2）利用域名获取IP地址：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyname(const char * hostname);&#x2F;&#x2F;成hostent结构体地址，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hostent结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hostent&#123;    char * h_name;&#x2F;&#x2F;官方域名    char ** h_aliases;&#x2F;&#x2F;alias list,同一个IP可以绑定多个域名    int h_addrtype;&#x2F;&#x2F;host address type    int h_length;&#x2F;&#x2F;保存IP地址长度    char ** h_addr_list;&#x2F;&#x2F;最重要的成员，通过此变量以整数形式保存域名对应的IP地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYbtI.png"></p><h3 id="（3）利用IP地址获取域名："><a href="#（3）利用IP地址获取域名：" class="headerlink" title="（3）利用IP地址获取域名："></a>（3）利用IP地址获取域名：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyaddr(const char *addr,socklen_t len,int family);&#x2F;&#x2F;成hostent结构体地址值，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（一）</title>
      <link href="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：笔记偏向Linux网络编程（此部分windows系统与其差别不大）</p><h2 id="1-网络编程与套接字"><a href="#1-网络编程与套接字" class="headerlink" title="1.网络编程与套接字"></a>1.网络编程与套接字</h2><h3 id="（1）调用socket函数创建套接字："><a href="#（1）调用socket函数创建套接字：" class="headerlink" title="（1）调用socket函数创建套接字："></a>（1）调用socket函数创建套接字：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（2）调用-bind-函数分配IP地址和端口号："><a href="#（2）调用-bind-函数分配IP地址和端口号：" class="headerlink" title="（2）调用 bind 函数分配IP地址和端口号："></a>（2）调用 bind 函数分配IP地址和端口号：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket.h&gt; int bind(int sockfd, strcuct sockaddr *myaddr, socklen_t addrlen);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）调用listen函数转为可接受请求状态："><a href="#（3）调用listen函数转为可接受请求状态：" class="headerlink" title="（3）调用listen函数转为可接受请求状态："></a>（3）调用listen函数转为可接受请求状态：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int listen(int sockfd,int backlog);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）调用accept函数受理连接请求："><a href="#（4）调用accept函数受理连接请求：" class="headerlink" title="（4）调用accept函数受理连接请求："></a>（4）调用accept函数受理连接请求：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-基于Linux的文件操作"><a href="#2-基于Linux的文件操作" class="headerlink" title="2.基于Linux的文件操作"></a>2.基于Linux的文件操作</h2><h3 id="（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）"><a href="#（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）" class="headerlink" title="（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）"></a>（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）</h3><p>分配给标准输入输出及标准错误的文件描述符：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsq29.png"></p><h3 id="（2）打开文件"><a href="#（2）打开文件" class="headerlink" title="（2）打开文件"></a>（2）打开文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;fcntl.h&gt;int open(const char *path,int flag);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag可能的值与含义：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsLvR.png"></p><h3 id="（3）关闭文件"><a href="#（3）关闭文件" class="headerlink" title="（3）关闭文件"></a>（3）关闭文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int close(int fd);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）将数据写入文件"><a href="#（4）将数据写入文件" class="headerlink" title="（4）将数据写入文件"></a>（4）将数据写入文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）读取文件中的数据"><a href="#（4）读取文件中的数据" class="headerlink" title="（4）读取文件中的数据"></a>（4）读取文件中的数据</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数（但遇到文件结尾则返回0），失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-套接字类型与协议设置"><a href="#3-套接字类型与协议设置" class="headerlink" title="3.套接字类型与协议设置"></a>3.套接字类型与协议设置</h2><h3 id="（1）协议族"><a href="#（1）协议族" class="headerlink" title="（1）协议族"></a>（1）协议族</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9vsb8J.png"></p><p>一般只用PF_INET(IPv4互联网协议族)</p><h3 id="（2）套接字类型"><a href="#（2）套接字类型" class="headerlink" title="（2）套接字类型"></a>（2）套接字类型</h3><p>SOCK_STREAM(面向连接):</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsHC4.png"></p><p>SOCK_SGRAM（面向消息）:</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsT5F.png"></p><p>*第三个参数一般为0（数据传输方式相同， 但协议不同。 此时需要通过第3个参数具体指定协议信息）</p><h2 id="4-地址族与数据序列"><a href="#4-地址族与数据序列" class="headerlink" title="4.地址族与数据序列"></a>4.地址族与数据序列</h2><h3 id="（1）表示IPv4地址的结构体"><a href="#（1）表示IPv4地址的结构体" class="headerlink" title="（1）表示IPv4地址的结构体"></a>（1）表示IPv4地址的结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">stuct sockaddr_in &#123;    sa_family_t sin_family sin_family;&#x2F;&#x2F;地址族（Address Family）    uint16_t         sin_port;&#x2F;&#x2F;16位TCP&#x2F;UDP端口号    struct in_addr   sin_addr;&#x2F;&#x2F;32位IP地址    char             sin_zero[0];&#x2F;&#x2F;不使用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct in_addr&#123;    in_addr_t    s_addr;&#x2F;&#x2F;32位IPv4地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*POSIX中定义的数据类型（用于提高扩展性）</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsjDx.png"></p><h3 id="（2）结构体sockaddr-in成员分析"><a href="#（2）结构体sockaddr-in成员分析" class="headerlink" title="（2）结构体sockaddr_in成员分析"></a>（2）结构体sockaddr_in成员分析</h3><p>sin_family：地址族，一般为AF_INET</p><p>sin_port：保存16位端口</p><p>sin_addr：保存32位IP地址信息</p><h3 id="（3）网络字节序"><a href="#（3）网络字节序" class="headerlink" title="（3）网络字节序"></a>（3）网络字节序</h3><p>网络字节序位为大端模式，主机字节序为小端模式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned short htons(unsigned short); unsigned short ntohs(unsîgned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>h代表主机字节序，n代表网络字节序</p><h3 id="（4）网络地址的初始化与分配"><a href="#（4）网络地址的初始化与分配" class="headerlink" title="（4）网络地址的初始化与分配"></a>（4）网络地址的初始化与分配</h3><p>将字符串形式的IP地址转换成32位整数型数据（此类型在转换类型的同时进行网络字节序转换）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int_addr_t inet_addr(const char* string);&#x2F;&#x2F;成功时返回32位大端序整数型值，失败时返回INADDR_NODE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_aton(const char* string,struct in_addr *addr);&#x2F;&#x2F;成功时返回1，失败时返回0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>*后者传递in_addr结构体变量地址值，函数会自动把结果填入该结构体得到变量，所以使用频率更高。</p><p>反过来转换：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_ntoa(struct in_addr adr);&#x2F;&#x2F;成功时返回转换的字符串地址值，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建套接字常见的网络地址信息初始化方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sockaddr_in addr; char * serv_ip &#x3D; &quot;211.117.168.13&quot;;     &#x2F;&#x2F;声明 IP 地址字符串char * serv_port &#x3D; &quot;9190&quot;;           &#x2F;&#x2F;声明端口号字符串memset(&amp;addr, 0 , sizeof(addr));     &#x2F;&#x2F;结构体addr的所有成员初始化为0addr.sin_family &#x3D; AF_INET;           &#x2F;&#x2F; 指定地址族addr.sin_addr.s_addr &#x3D; inet_addr(serv_ip);  &#x2F;&#x2F;基于字符串IP地址初始化addr.sin_port &#x3D; htons(atoi(serv_port));     &#x2F;&#x2F;基于字符串的端口号初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次创建服务器端套接字都要输入 地址会有些繁琐，此时可如下初始化地址信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sckaddr_in addr;char * serv_port &#x3D;&quot;9190&quot;;memset(&amp;addr,0,szieof(addr));addr.sin_family&#x3D;AF_INET;addr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);addr.sin_port&#x3D;htons(atoi(serv_port));&#x2F;&#x2F;利用常数可自动获取服务器端的计算机IP，不用手动输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-基于TCP的服务器端-x2F-客户端"><a href="#5-基于TCP的服务器端-x2F-客户端" class="headerlink" title="5.基于TCP的服务器端&#x2F;客户端"></a>5.基于TCP的服务器端&#x2F;客户端</h2><h3 id="（1）TCP-服务器端-x2F-客户端的函数调用关系"><a href="#（1）TCP-服务器端-x2F-客户端的函数调用关系" class="headerlink" title="（1）TCP 服务器端&#x2F;客户端的函数调用关系"></a>（1）TCP 服务器端&#x2F;客户端的函数调用关系</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9vyCPe.png"></p><h3 id="（2）迭代回声服务器-x2F-客户端"><a href="#（2）迭代回声服务器-x2F-客户端" class="headerlink" title="（2）迭代回声服务器&#x2F;客户端"></a>（2）迭代回声服务器&#x2F;客户端</h3><p>程序基本运行方式：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyp5D.png"><br>服务器端(echo_sever.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;++i)    &#123;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             error_handling(&quot;accept() error&quot;);        else            printf(&quot;connect client %d\n&quot;,i+1);        while((str_len&#x3D;read(clnt_sock,message,BUF_SIZE))!&#x3D;0)            write(clnt_sock,message,str_len);        close(clnt_sock);        return 0;    &#125;    close(serv_sock);    return 0;&#125;   void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端(echo_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    while(1)    &#123;        fputs(&quot;input message(Q to quit):&quot;,stdout);        fgets(message,BUF_SIZE,stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;                write(sock,message,strlen(message));        str_len&#x3D;read(sock,message,BUF_SIZE-1);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server %s\n&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回声客户端存在的问题：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyi2d.png"></p><p>修改迭代部分：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyAKI.png"></p><h3 id="（3）计算器服务器端-x2F-客户端示例"><a href="#（3）计算器服务器端-x2F-客户端示例" class="headerlink" title="（3）计算器服务器端&#x2F;客户端示例"></a>（3）计算器服务器端&#x2F;客户端示例</h3><p>客户端设计如下应用层协议：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyP8H.png"></p><p>客户端(op_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define RLT_SIZE 4#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int main(int argc,char *argv[])&#123;    int sock;    char opmsg[BUF_SIZE];    int result,opnd_cnt;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;usage:%s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)        error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error&quot;);    else       fputs(&quot;operand count:&quot;,stdout);       scanf(&quot;%d&quot;,&amp;opnd_cnt);       opmsg[0]&#x3D;(char)opnd_cnt;       for(int i&#x3D;0;i&lt;opnd_cnt;++i)       &#123;        printf(&quot;operand %d:&quot;,i+1);        scanf(&quot;%d&quot;,(int*)&amp;opmsg[i*OPSZ+1]);       &#125;       fgetc(stdin);       fputs(&quot;operator:&quot;,stdout);       scanf(&quot;%c&quot;,&amp;opmsg[opnd_cnt*OPSZ+1]);       write(sock,opmsg,opnd_cnt*OPSZ+2);       read(sock,&amp;result,RLT_SIZE);       printf(&quot;operation result:%d\n&quot;,result);       close(sock);       return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端(op_server.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int calculate(int opnum,int opnds[],char oprator);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char opinfo[BUF_SIZE];    int result,opnd_cnt;    int recv_cnt,recv_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc !&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    if(serv_sock&#x3D;&#x3D;-1)        error_handling(&quot;socket error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1)        error_handling(&quot;listen error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;i++)    &#123;        opnd_cnt&#x3D;0;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr *)&amp;clnt_adr,&amp;clnt_adr_sz);        read(clnt_sock,&amp;opnd_cnt,1);        recv_len&#x3D;0;        while((opnd_cnt*OPSZ+1)&gt;recv_len)        &#123;            recv_cnt&#x3D;read(clnt_sock,&amp;opinfo[recv_len],BUF_SIZE-1);            recv_len+&#x3D;recv_cnt;        &#125;        result&#x3D;calculate(opnd_cnt,(int*)opinfo,opinfo[recv_len-1]);        write(clnt_sock,(char*)&amp;result,sizeof(result));        close(clnt_sock);                &#125;    close(serv_sock);    return 0;&#125;int calculate(int opnum,int opnds[],char op)&#123;    int result&#x3D;opnds[0];    switch(op)    &#123;        case &#39;+&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result+&#x3D;opnds[i];            break;        case &#39;-&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result-&#x3D;opnds[i];            break;        case &#39;*&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result*&#x3D;opnds[i];            break;        case &#39;&#x2F;&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result&#x2F;&#x3D;opnds[i];            break;    &#125;    return result;;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）TCP内部工作原理"><a href="#（4）TCP内部工作原理" class="headerlink" title="（4）TCP内部工作原理"></a>（4）TCP内部工作原理</h3><p>a.与对方套接字的连接（三次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyFxA.png"></p><p>套接字是以全双工（Full-duplex）方式工作的，可以双向传递数据。</p><p>b.与对方主机的数据交换：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyErt.png"></p><p>有超时重传机制</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgLFK.png"></p><p>c.断开与套接字的连接（四次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgfWF.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
