<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP/IP网络编程（一）</title>
      <link href="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：笔记偏向Linux网络编程（此部分windows系统与其差别不大）</p><h2 id="1-网络编程与套接字"><a href="#1-网络编程与套接字" class="headerlink" title="1.网络编程与套接字"></a>1.网络编程与套接字</h2><h3 id="（1）调用socket函数创建套接字："><a href="#（1）调用socket函数创建套接字：" class="headerlink" title="（1）调用socket函数创建套接字："></a>（1）调用socket函数创建套接字：</h3><pre><code>#include &lt;sys/socket. h&gt; int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1</code></pre><h3 id="（2）调用-bind-函数分配IP地址和端口号："><a href="#（2）调用-bind-函数分配IP地址和端口号：" class="headerlink" title="（2）调用 bind 函数分配IP地址和端口号："></a>（2）调用 bind 函数分配IP地址和端口号：</h3><pre><code>#include &lt;sys/socket.h&gt; int bind(int sockfd, strcuct sockaddr *myaddr, socklen_t addrlen);//成功时返回0，失败时返回-1</code></pre><h3 id="（3）调用listen函数转为可接受请求状态："><a href="#（3）调用listen函数转为可接受请求状态：" class="headerlink" title="（3）调用listen函数转为可接受请求状态："></a>（3）调用listen函数转为可接受请求状态：</h3><pre><code>#include&lt;sys/socket.h&gt;int listen(int sockfd,int backlog);//成功时返回0，失败时返回-1</code></pre><h3 id="（4）调用accept函数受理连接请求："><a href="#（4）调用accept函数受理连接请求：" class="headerlink" title="（4）调用accept函数受理连接请求："></a>（4）调用accept函数受理连接请求：</h3><pre><code>#include&lt;sys/socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);//成功时返回文件描述符，失败时返回-1</code></pre><h2 id="2-基于Linux的文件操作"><a href="#2-基于Linux的文件操作" class="headerlink" title="2.基于Linux的文件操作"></a>2.基于Linux的文件操作</h2><h3 id="（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）"><a href="#（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）" class="headerlink" title="（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）"></a>（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）</h3><p>分配给标准输入输出及标准错误的文件描述符：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-29-23-43-57.png"></p><h3 id="（2）打开文件"><a href="#（2）打开文件" class="headerlink" title="（2）打开文件"></a>（2）打开文件</h3><pre><code>#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int open(const char *path,int flag);//成功时返回文件描述符，失败时返回-1</code></pre><p>flag可能的值与含义：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-29-23-48-51.png"></p><h3 id="（3）关闭文件"><a href="#（3）关闭文件" class="headerlink" title="（3）关闭文件"></a>（3）关闭文件</h3><pre><code>#include&lt;unistd.h&gt;int close(int fd);//成功时返回0，失败时返回-1</code></pre><h3 id="（4）将数据写入文件"><a href="#（4）将数据写入文件" class="headerlink" title="（4）将数据写入文件"></a>（4）将数据写入文件</h3><pre><code>#include&lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes);//成功石返回写入的字节数，失败时返回-1</code></pre><h3 id="（4）读取文件中的数据"><a href="#（4）读取文件中的数据" class="headerlink" title="（4）读取文件中的数据"></a>（4）读取文件中的数据</h3><pre><code>#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t nbytes);//成功石返回写入的字节数（但遇到文件结尾则返回0），失败时返回-1</code></pre><h2 id="3-套接字类型与协议设置"><a href="#3-套接字类型与协议设置" class="headerlink" title="3.套接字类型与协议设置"></a>3.套接字类型与协议设置</h2><h3 id="（1）协议族"><a href="#（1）协议族" class="headerlink" title="（1）协议族"></a>（1）协议族</h3><pre><code>#include &lt;sys/socket. h&gt; int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1</code></pre><p>一般只用PF_INET(IPv4互联网协议族)</p><h3 id="（2）套接字类型"><a href="#（2）套接字类型" class="headerlink" title="（2）套接字类型"></a>（2）套接字类型</h3><p>SOCK_STREAM(面向连接):<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-09-17-52.png"><br>SOCK_SGRAM（面向消息）:<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-09-18-23.png"></p><p>*第三个参数一般为0（数据传输方式相同， 但协议不同。 此时需要通过第3个参数具体指定协议信息）</p><h2 id="4-地址族与数据序列"><a href="#4-地址族与数据序列" class="headerlink" title="4.地址族与数据序列"></a>4.地址族与数据序列</h2><h3 id="（1）表示IPv4地址的结构体"><a href="#（1）表示IPv4地址的结构体" class="headerlink" title="（1）表示IPv4地址的结构体"></a>（1）表示IPv4地址的结构体</h3><pre><code>stuct sockaddr_in &#123;    sa_family_t sin_family sin_family;//地址族（Address Family）    uint16_t         sin_port;//16位TCP/UDP端口号    struct in_addr   sin_addr;//32位IP地址    char             sin_zero[0];//不使用&#125;</code></pre><p>该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址</p><pre><code>struct in_addr&#123;    in_addr_t    s_addr;//32位IPv4地址&#125;</code></pre><p>*POSIX中定义的数据类型（用于提高扩展性）<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-09-32-44.png"></p><h3 id="（2）结构体sockaddr-in成员分析"><a href="#（2）结构体sockaddr-in成员分析" class="headerlink" title="（2）结构体sockaddr_in成员分析"></a>（2）结构体sockaddr_in成员分析</h3><p>sin_family：地址族，一般为AF_INET</p><p>sin_port：保存16位端口</p><p>sin_addr：保存32位IP地址信息</p><h3 id="（3）网络字节序"><a href="#（3）网络字节序" class="headerlink" title="（3）网络字节序"></a>（3）网络字节序</h3><p>网络字节序位为大端模式，主机字节序为小端模式</p><pre><code>unsigned short htons(unsigned short); unsigned short ntohs(unsîgned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long);</code></pre><p>h代表主机字节序，n代表网络字节序</p><h3 id="（4）网络地址的初始化与分配"><a href="#（4）网络地址的初始化与分配" class="headerlink" title="（4）网络地址的初始化与分配"></a>（4）网络地址的初始化与分配</h3><p>将字符串形式的IP地址转换成32位整数型数据（此类型在转换类型的同时进行网络字节序转换）</p><pre><code>#include&lt;arpa/inet.h&gt;int_addr_t inet_addr(const char* string);//成功时返回32位大端序整数型值，失败时返回INADDR_NODE</code></pre><pre><code>#include&lt;arpa/inet.h&gt;int inet_aton(const char* string,struct in_addr *addr);//成功时返回1，失败时返回0</code></pre><p><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-09-55-22.png"><br>*后者传递in_addr结构体变量地址值，函数会自动把结果填入该结构体得到变量，所以使用频率更高。</p><p>反过来转换：</p><pre><code>#include&lt;arpa/inet.h&gt;int inet_ntoa(struct in_addr adr);//成功时返回转换的字符串地址值，失败时返回-1</code></pre><p>创建套接字常见的网络地址信息初始化方法：</p><pre><code>struct sockaddr_in addr; char * serv_ip = &quot;211.117.168.13&quot;;     //声明 IP 地址字符串char * serv_port = &quot;9190&quot;;           //声明端口号字符串memset(&amp;addr, 0 , sizeof(addr));     //结构体addr的所有成员初始化为0addr.sin_family = AF_INET;           // 指定地址族addr.sin_addr.s_addr = inet_addr(serv_ip);  //基于字符串IP地址初始化addr.sin_port = htons(atoi(serv_port));     //基于字符串的端口号初始化</code></pre><p>每次创建服务器端套接字都要输入 地址会有些繁琐，此时可如下初始化地址信息：</p><pre><code>struct sckaddr_in addr;char * serv_port =&quot;9190&quot;;memset(&amp;addr,0,szieof(addr));addr.sin_family=AF_INET;addr.sin_addr.s_addr=htonl(INADDR_ANY);addr.sin_port=htons(atoi(serv_port));//利用常数可自动获取服务器端的计算机IP，不用手动输入</code></pre><h2 id="5-基于TCP的服务端-x2F-客户端"><a href="#5-基于TCP的服务端-x2F-客户端" class="headerlink" title="5.基于TCP的服务端&#x2F;客户端"></a>5.基于TCP的服务端&#x2F;客户端</h2><h3 id="（1）TCP-服务器端-x2F-客户端的函数调用关系"><a href="#（1）TCP-服务器端-x2F-客户端的函数调用关系" class="headerlink" title="（1）TCP 服务器端&#x2F;客户端的函数调用关系"></a>（1）TCP 服务器端&#x2F;客户端的函数调用关系</h3><p><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-13-29-18.png"></p><h3 id="（2）迭代回声服务器-x2F-客户端"><a href="#（2）迭代回声服务器-x2F-客户端" class="headerlink" title="（2）迭代回声服务器&#x2F;客户端"></a>（2）迭代回声服务器&#x2F;客户端</h3><p>程序基本运行方式：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-13-34-33.png"><br>服务端(echo_sever.c)：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;sys/socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc!=2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock=socket(PF_INET,SOCK_STREAM,0);    if(serv_sock==-1)         error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family=AF_INET;    serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);    serv_adr.sin_port=htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))==-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)==-1) //同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    clnt_adr_sz=sizeof(clnt_adr);    for(int i=0;i&lt;5;++i)    &#123;        clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        if(clnt_sock==-1)             error_handling(&quot;accept() error&quot;);        else            printf(&quot;connect client %d\n&quot;,i+1);        while((str_len=read(clnt_sock,message,BUF_SIZE))!=0)            write(clnt_sock,message,str_len);        close(clnt_sock);        return 0;    &#125;    close(serv_sock);    return 0;&#125;   void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;</code></pre><p>客户端（echo_client.c）：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;sys/socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr;    if(argc!=3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock=socket(PF_INET, SOCK_STREAM,0);    if(sock==-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family=AF_INET;    serv_adr.sin_addr.s_addr=inet_addr(argv[1]);    serv_adr.sin_port=htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))==-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    while(1)    &#123;        fputs(&quot;input message(Q to quit):&quot;,stdout);        fgets(message,BUF_SIZE,stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;                write(sock,message,strlen(message));        str_len=read(sock,message,BUF_SIZE-1);        message[str_len]=&#39;\0&#39;;        printf(&quot;message from server %s\n&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;</code></pre><p>回声客户端存在的问题：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-16-05-09.png"></p><p>修改迭代部分：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-16-33-26.png"></p><h3 id="（3）计算器服务端-x2F-客户端示例"><a href="#（3）计算器服务端-x2F-客户端示例" class="headerlink" title="（3）计算器服务端&#x2F;客户端示例"></a>（3）计算器服务端&#x2F;客户端示例</h3><p>客户端设计如下应用层协议：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-20-42-44.png"><br>客户端（op_client.c）：<br>服务端（op_server.c）：<br>（记得补充）</p><h3 id="（4）TCP内部工作原理"><a href="#（4）TCP内部工作原理" class="headerlink" title="（4）TCP内部工作原理"></a>（4）TCP内部工作原理</h3><p>a.与对方套接字的连接（三次握手）：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-21-03-00.png"><br>套接字是以全双工（Full-duplex）方式工作的，可以双向传递数据。</p><p>b.与对方主机的数据交换：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-21-20-43.png"><br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-21-23-03.png"></p><p>c.断开与套接字的连接（四次握手）：<br><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-21-25-42.png"></p><h3 id="（5）编写程序，使服务端和客户端各传递1次字符串，传递字符串先以4字节整型方式传递字符串长度"><a href="#（5）编写程序，使服务端和客户端各传递1次字符串，传递字符串先以4字节整型方式传递字符串长度" class="headerlink" title="（5）编写程序，使服务端和客户端各传递1次字符串，传递字符串先以4字节整型方式传递字符串长度"></a>（5）编写程序，使服务端和客户端各传递1次字符串，传递字符串先以4字节整型方式传递字符串长度</h3><p>（记得补充）</p><h3 id="（6）创建收发文件的服务端-x2F-客户端，实现顺序如下："><a href="#（6）创建收发文件的服务端-x2F-客户端，实现顺序如下：" class="headerlink" title="（6）创建收发文件的服务端&#x2F;客户端，实现顺序如下："></a>（6）创建收发文件的服务端&#x2F;客户端，实现顺序如下：</h3><p><img src="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/2023-05-30-21-41-34.png"><br>（记得补充）</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/28/hello-world/"/>
      <url>/2023/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
