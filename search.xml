<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP/IP网络编程（三）</title>
      <link href="/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<p>前言：该内容基于Linux平台，且笔记比较精简，省略了笔者大量思考内容，但有助于知识点复盘。</p><h2 id="9-套接字的多种可选项"><a href="#9-套接字的多种可选项" class="headerlink" title="9.套接字的多种可选项"></a>9.套接字的多种可选项</h2><h3 id="（1）套接字的多种可选项："><a href="#（1）套接字的多种可选项：" class="headerlink" title="（1）套接字的多种可选项："></a>（1）套接字的多种可选项：</h3><p><img src="https://s1.ax1x.com/2023/06/02/p9zh7Gt.png"><br><img src="https://s1.ax1x.com/2023/06/02/p9z4pin.png"></p><h3 id="（2）getsocket-amp-setsocket"><a href="#（2）getsocket-amp-setsocket" class="headerlink" title="（2）getsocket &amp; setsocket"></a>（2）getsocket &amp; setsocket</h3><p>可选项的的读取和设置由以下两个函数完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int getsockopt(int sock,int level,int optname,void *optval,socklen_t *optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhIIA.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int setsockopt(int sock,int level,int optname,const void *optval,socklen_t optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhHRP.png"></p><h4 id="用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）："><a href="#用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）：" class="headerlink" title="用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）："></a>用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;socket.h&gt;void error_handling(char *message);int main(int argc, char *argv[])&#123;    int tcp_sock,udp_sock;    int sock_type;    socklen_t optlen;    int state;    optlen&#x3D;sizeof(sock_type);    tcp_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    udp_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    printf(&quot;SOCK_STREAM:%d\n&quot;,SOCK_STREAM);    printf(&quot;SOCK_DGRAM:%d\n&quot;,SOCK_DGRAM);    state&#x3D;getsockopt(tcp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type one:%d\n&quot;,sock_type);        state&#x3D;getsockopt(udp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type two:%d\n&quot;,sock_type);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhTPI.png"></p><h3 id="（3）SO-SNDBUF-amp-SO-RCVBUF"><a href="#（3）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="（3）SO_SNDBUF &amp; SO_RCVBUF"></a>（3）SO_SNDBUF &amp; SO_RCVBUF</h3><p> 前者是输入缓冲大小相关可选项，后者输出的，这两个可选项既可以读取当前I&#x2F;O缓冲大小，也可以进行更改。（代码和上面差不多）</p><h3 id="（4）SO-REUSEADDR"><a href="#（4）SO-REUSEADDR" class="headerlink" title="（4）SO_REUSEADDR"></a>（4）SO_REUSEADDR</h3><p> 假设主机A的四次握手过程中最后的数据丢失，则主机B会认为A未能收到自己发送的FIN消息，因此重传。此时收到FIN消息的主机A将重启Time_wait计时器。所以网络状况不理想的话，Time_wait状态将持续。</p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhbxf.png"></p><p>解决方法就是在套接字的可选项中更改SO_REUSEADDR的状态，将默认值0改为:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">optlen&#x3D;sizeof(option);option&#x3D;TRUE;setsockopt(serv_sock,SOL_SOCKET,SO_REUSEADDR,(void*)&amp;option,optlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（5）TCP-NODELAY"><a href="#（5）TCP-NODELAY" class="headerlink" title="（5）TCP_NODELAY"></a>（5）TCP_NODELAY</h3><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p><img src="https://s1.ax1x.com/2023/06/02/p9zhLM8.png"></p><p>但传输大文件数据时即使不使用该算法也会在装满缓冲时传输数据包，这样不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。</p><h4 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">int opt_val&#x3D;1;setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(void *)&amp;opt_val,sizeof(opt_val));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="10-多进程服务器端"><a href="#10-多进程服务器端" class="headerlink" title="10.多进程服务器端"></a>10.多进程服务器端</h2><h3 id="（1）进程"><a href="#（1）进程" class="headerlink" title="（1）进程"></a>（1）进程</h3><h4 id="并发服务器的实现方法"><a href="#并发服务器的实现方法" class="headerlink" title="并发服务器的实现方法"></a>并发服务器的实现方法</h4><p>如下图所示：（多进程服务器Windows平台不支持）<br><img src="https://s1.ax1x.com/2023/06/02/p9zhxaj.png"></p><h4 id="调用fork函数创建进程"><a href="#调用fork函数创建进程" class="headerlink" title="调用fork函数创建进程"></a>调用fork函数创建进程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;pid_t fork(void);&#x2F;&#x2F;成进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过同一个进程复制相同的内存空间，之后的程序要根据返回值加以区分：</p><p>父进程：fork函数返回子进程id</p><p>子进程：fork函数返回0</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>为了摧毁子进程，父进程应主动请求获取子进程的返回值，<strong>方法其一</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t wait(int* statloc);&#x2F;&#x2F;成子进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用此函数如果有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值&#x2F;main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离：</p><p>WIFEXITED:子进程正常终止时返回true</p><p>WEXITSTATUS：返回子进程的返回值</p><p>向wait函数传递变量status的地址时，调用wait函数后应编写如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(WIFEXITED(status))&#123;    puts(&quot;normal termination&quot;);    printf(&quot;child pass num:%d&quot;,WEXITSTATUS(status));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用wait函数时，如果没有已终止的子进程，那么程序将阻塞直到有子进程终止，谨慎使用。</p><p><strong>方法其二</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t waitpid(pid_t pid,int *statloc,int options);&#x2F;&#x2F;成返回终止的子进程id或0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhOsS.png"></p><h3 id="（2）信号处理"><a href="#（2）信号处理" class="headerlink" title="（2）信号处理"></a>（2）信号处理</h3><p>进程发现自己的子进程结束时，请求操作系统调用特定函数（信号注册函数）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;void (*signal(int signo,void(*func)(int)))(int);&#x2F;&#x2F;为了在产生信号时调用，返回之前注册的函数指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhXqg.png"></p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhvZQ.png"></p><h4 id="编写signal函数"><a href="#编写signal函数" class="headerlink" title="编写signal函数"></a>编写signal函数</h4><p><strong>请求</strong> 已到通过alarm函数注册的时间，调用timeout函数；输入CTRL+C时调用keycontrol函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void timeout(int sig)&#123;    if(sig&#x3D;&#x3D;SIGALRM)        puts(&quot;time out&quot;);    alarm(2);&#125;void keycontrol(int sig)&#123;    if(sig&#x3D;&#x3D;SIGINT)        puts(&quot;CTRL+C pressed&quot;);&#125;int main(int argc,char *argv[])&#123;    signal(SIGALRM,timeout);    signal(SIGINT,keycontrol);    alarm(2);    for(int i&#x3D;0;i&lt;3;++i)    &#123;        puts(&quot;wait....&quot;);        sleep(100);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhzIs.png"></p><h4 id="利用sigaction函数进行信号处理-更稳定"><a href="#利用sigaction函数进行信号处理-更稳定" class="headerlink" title="利用sigaction函数进行信号处理(更稳定)"></a>利用sigaction函数进行信号处理(更稳定)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;int sigaction(int signo,const struct sigaction *act,struct sigaction * oldact);&#x2F;&#x2F;成0，败1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9z49Gq.png"></p><p>声明并初始化sigaction结构体变量以调用上述函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sigaction&#123;    void (*sa_handler)(int);    sigset_t sa_mask;    int sa_flags;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（二）</title>
      <link href="/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<p>前言：本章学习有关UDP的特点以及网络编程（Linux平台）</p><h2 id="6-基于UDP的服务器端-x2F-客户端"><a href="#6-基于UDP的服务器端-x2F-客户端" class="headerlink" title="6.基于UDP的服务器端&#x2F;客户端"></a>6.基于UDP的服务器端&#x2F;客户端</h2><h3 id="（1）基于UDP的数据I-x2F-O函数"><a href="#（1）基于UDP的数据I-x2F-O函数" class="headerlink" title="（1）基于UDP的数据I&#x2F;O函数"></a>（1）基于UDP的数据I&#x2F;O函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t sendto(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *to,socklen_t addrlen);&#x2F;&#x2F;成功时返回传输的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYf1K.png"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t recvfrom(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t addrlen);&#x2F;&#x2F;成功接受的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYIne.png"></p><h3 id="2-基于UDP的回声服务器端-x2F-客户端"><a href="#2-基于UDP的回声服务器端-x2F-客户端" class="headerlink" title="(2)基于UDP的回声服务器端&#x2F;客户端"></a>(2)基于UDP的回声服务器端&#x2F;客户端</h3><p>sendto函数自动分配IP和端口号，所以UDP客户端中通常无需额外的地址分配过程</p><p>服务器端：uechos.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int serv_sock;    char message[BUF_SIZE];    int str_len;    socklen_t clnt_adr_sz;    struct sockaddr_in serv_adr,clnt_adr;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(serv_sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;binding error&quot;);    &#125;    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        str_len&#x3D;recvfrom(serv_sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        sendto(serv_sock,message,str_len,0,(struct sockaddr*)&amp;clnt_adr,clnt_adr_sz);    &#125;    close(serv_sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：uechoc.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    socklen_t adr_sz;    struct sockaddr_in serv_adr,from_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    while(1)    &#123;        fputs(&quot;insert ,message(q to quit):&quot;,stdout);        fgets(message,sizeof(message),stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;        sendto(sock,message,strlen(message),0,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));        adr_sz&#x3D;sizeof(from_adr);        str_len&#x3D;recvfrom(sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;from_adr,&amp;adr_sz);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server:%s&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYHAA.png"></p><h3 id="（3）已连接UDP套接字与未连接UDP套接字"><a href="#（3）已连接UDP套接字与未连接UDP套接字" class="headerlink" title="（3）已连接UDP套接字与未连接UDP套接字"></a>（3）已连接UDP套接字与未连接UDP套接字</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9xYo0H.png"></p><p>每次调用sendto函数重复上述过程，每次都变更目标地址，因此可以重复利用同一套UDP套接字向不同目标传输数据。这种未注册目标地点信息的套接字称为未连接套接字。</p><p>创建已连接UDP套接字：</p><pre class="line-numbers language-none"><code class="language-none">sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);memset(&amp;adr,0,sizeof(adr));adr.sin_family&#x3D;AF_INET;adr.sin_addr.s_addr&#x3D;...adr.sin_port&#x3D;...connect(sock,(struct sockaddr*)&amp;adr,sizeof(adr));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后与TCP套接字一样，每次调用sendto函数时只需传输数据。因为已经指定了收发对象，所以还可以使用write,read函数进行通信。</p><h2 id="7-优雅地断开套接字的连接"><a href="#7-优雅地断开套接字的连接" class="headerlink" title="7.优雅地断开套接字的连接"></a>7.优雅地断开套接字的连接</h2><h3 id="1-shutdown函数"><a href="#1-shutdown函数" class="headerlink" title="(1)shutdown函数"></a>(1)shutdown函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;int shutdown(int sock,int howto);&#x2F;&#x2F;成0败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个值：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xY4XD.png"></p><h3 id="2-半关闭"><a href="#2-半关闭" class="headerlink" title="(2)半关闭"></a>(2)半关闭</h3><p>调用close函数的同时关闭I&#x2F;O流，这样也会向对方发送EOF，但此时无法接受对方传输的数据。调用shutdown函数只关闭输出流，这样既可以发送EOF，又保留了输入流，可以接受对方数据。</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYO9P.png"></p><h2 id="8-域名及网络地址"><a href="#8-域名及网络地址" class="headerlink" title="8.域名及网络地址"></a>8.域名及网络地址</h2><h3 id="（1）域名系统"><a href="#（1）域名系统" class="headerlink" title="（1）域名系统"></a>（1）域名系统</h3><h4 id="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"><a href="#DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。" class="headerlink" title="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"></a>DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。</h4><p>域名：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYT7d.png"></p><p>DNS获取IP地址信息：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYqht.png"></p><h3 id="（2）利用域名获取IP地址："><a href="#（2）利用域名获取IP地址：" class="headerlink" title="（2）利用域名获取IP地址："></a>（2）利用域名获取IP地址：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyname(const char * hostname);&#x2F;&#x2F;成hostent结构体地址，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hostent结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hostent&#123;    char * h_name;&#x2F;&#x2F;官方域名    char ** h_aliases;&#x2F;&#x2F;alias list,同一个IP可以绑定多个域名    int h_addrtype;&#x2F;&#x2F;host address type    int h_length;&#x2F;&#x2F;保存IP地址长度    char ** h_addr_list;&#x2F;&#x2F;最重要的成员，通过此变量以整数形式保存域名对应的IP地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYbtI.png"></p><h3 id="（3）利用IP地址获取域名："><a href="#（3）利用IP地址获取域名：" class="headerlink" title="（3）利用IP地址获取域名："></a>（3）利用IP地址获取域名：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyaddr(const char *addr,socklen_t len,int family);&#x2F;&#x2F;成hostent结构体地址值，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（一）</title>
      <link href="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：笔记偏向Linux网络编程（此部分windows系统与其差别不大）</p><h2 id="1-网络编程与套接字"><a href="#1-网络编程与套接字" class="headerlink" title="1.网络编程与套接字"></a>1.网络编程与套接字</h2><h3 id="（1）调用socket函数创建套接字："><a href="#（1）调用socket函数创建套接字：" class="headerlink" title="（1）调用socket函数创建套接字："></a>（1）调用socket函数创建套接字：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（2）调用-bind-函数分配IP地址和端口号："><a href="#（2）调用-bind-函数分配IP地址和端口号：" class="headerlink" title="（2）调用 bind 函数分配IP地址和端口号："></a>（2）调用 bind 函数分配IP地址和端口号：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket.h&gt; int bind(int sockfd, strcuct sockaddr *myaddr, socklen_t addrlen);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）调用listen函数转为可接受请求状态："><a href="#（3）调用listen函数转为可接受请求状态：" class="headerlink" title="（3）调用listen函数转为可接受请求状态："></a>（3）调用listen函数转为可接受请求状态：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int listen(int sockfd,int backlog);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）调用accept函数受理连接请求："><a href="#（4）调用accept函数受理连接请求：" class="headerlink" title="（4）调用accept函数受理连接请求："></a>（4）调用accept函数受理连接请求：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-基于Linux的文件操作"><a href="#2-基于Linux的文件操作" class="headerlink" title="2.基于Linux的文件操作"></a>2.基于Linux的文件操作</h2><h3 id="（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）"><a href="#（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）" class="headerlink" title="（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）"></a>（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）</h3><p>分配给标准输入输出及标准错误的文件描述符：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsq29.png"></p><h3 id="（2）打开文件"><a href="#（2）打开文件" class="headerlink" title="（2）打开文件"></a>（2）打开文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;fcntl.h&gt;int open(const char *path,int flag);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag可能的值与含义：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsLvR.png"></p><h3 id="（3）关闭文件"><a href="#（3）关闭文件" class="headerlink" title="（3）关闭文件"></a>（3）关闭文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int close(int fd);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）将数据写入文件"><a href="#（4）将数据写入文件" class="headerlink" title="（4）将数据写入文件"></a>（4）将数据写入文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）读取文件中的数据"><a href="#（4）读取文件中的数据" class="headerlink" title="（4）读取文件中的数据"></a>（4）读取文件中的数据</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数（但遇到文件结尾则返回0），失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-套接字类型与协议设置"><a href="#3-套接字类型与协议设置" class="headerlink" title="3.套接字类型与协议设置"></a>3.套接字类型与协议设置</h2><h3 id="（1）协议族"><a href="#（1）协议族" class="headerlink" title="（1）协议族"></a>（1）协议族</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9vsb8J.png"></p><p>一般只用PF_INET(IPv4互联网协议族)</p><h3 id="（2）套接字类型"><a href="#（2）套接字类型" class="headerlink" title="（2）套接字类型"></a>（2）套接字类型</h3><p>SOCK_STREAM(面向连接):</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsHC4.png"></p><p>SOCK_SGRAM（面向消息）:</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsT5F.png"></p><p>*第三个参数一般为0（数据传输方式相同， 但协议不同。 此时需要通过第3个参数具体指定协议信息）</p><h2 id="4-地址族与数据序列"><a href="#4-地址族与数据序列" class="headerlink" title="4.地址族与数据序列"></a>4.地址族与数据序列</h2><h3 id="（1）表示IPv4地址的结构体"><a href="#（1）表示IPv4地址的结构体" class="headerlink" title="（1）表示IPv4地址的结构体"></a>（1）表示IPv4地址的结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">stuct sockaddr_in &#123;    sa_family_t sin_family sin_family;&#x2F;&#x2F;地址族（Address Family）    uint16_t         sin_port;&#x2F;&#x2F;16位TCP&#x2F;UDP端口号    struct in_addr   sin_addr;&#x2F;&#x2F;32位IP地址    char             sin_zero[0];&#x2F;&#x2F;不使用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct in_addr&#123;    in_addr_t    s_addr;&#x2F;&#x2F;32位IPv4地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*POSIX中定义的数据类型（用于提高扩展性）</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsjDx.png"></p><h3 id="（2）结构体sockaddr-in成员分析"><a href="#（2）结构体sockaddr-in成员分析" class="headerlink" title="（2）结构体sockaddr_in成员分析"></a>（2）结构体sockaddr_in成员分析</h3><p>sin_family：地址族，一般为AF_INET</p><p>sin_port：保存16位端口</p><p>sin_addr：保存32位IP地址信息</p><h3 id="（3）网络字节序"><a href="#（3）网络字节序" class="headerlink" title="（3）网络字节序"></a>（3）网络字节序</h3><p>网络字节序位为大端模式，主机字节序为小端模式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned short htons(unsigned short); unsigned short ntohs(unsîgned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>h代表主机字节序，n代表网络字节序</p><h3 id="（4）网络地址的初始化与分配"><a href="#（4）网络地址的初始化与分配" class="headerlink" title="（4）网络地址的初始化与分配"></a>（4）网络地址的初始化与分配</h3><p>将字符串形式的IP地址转换成32位整数型数据（此类型在转换类型的同时进行网络字节序转换）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int_addr_t inet_addr(const char* string);&#x2F;&#x2F;成功时返回32位大端序整数型值，失败时返回INADDR_NODE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_aton(const char* string,struct in_addr *addr);&#x2F;&#x2F;成功时返回1，失败时返回0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>*后者传递in_addr结构体变量地址值，函数会自动把结果填入该结构体得到变量，所以使用频率更高。</p><p>反过来转换：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_ntoa(struct in_addr adr);&#x2F;&#x2F;成功时返回转换的字符串地址值，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建套接字常见的网络地址信息初始化方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sockaddr_in addr; char * serv_ip &#x3D; &quot;211.117.168.13&quot;;     &#x2F;&#x2F;声明 IP 地址字符串char * serv_port &#x3D; &quot;9190&quot;;           &#x2F;&#x2F;声明端口号字符串memset(&amp;addr, 0 , sizeof(addr));     &#x2F;&#x2F;结构体addr的所有成员初始化为0addr.sin_family &#x3D; AF_INET;           &#x2F;&#x2F; 指定地址族addr.sin_addr.s_addr &#x3D; inet_addr(serv_ip);  &#x2F;&#x2F;基于字符串IP地址初始化addr.sin_port &#x3D; htons(atoi(serv_port));     &#x2F;&#x2F;基于字符串的端口号初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次创建服务器端套接字都要输入 地址会有些繁琐，此时可如下初始化地址信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sckaddr_in addr;char * serv_port &#x3D;&quot;9190&quot;;memset(&amp;addr,0,szieof(addr));addr.sin_family&#x3D;AF_INET;addr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);addr.sin_port&#x3D;htons(atoi(serv_port));&#x2F;&#x2F;利用常数可自动获取服务器端的计算机IP，不用手动输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-基于TCP的服务器端-x2F-客户端"><a href="#5-基于TCP的服务器端-x2F-客户端" class="headerlink" title="5.基于TCP的服务器端&#x2F;客户端"></a>5.基于TCP的服务器端&#x2F;客户端</h2><h3 id="（1）TCP-服务器端-x2F-客户端的函数调用关系"><a href="#（1）TCP-服务器端-x2F-客户端的函数调用关系" class="headerlink" title="（1）TCP 服务器端&#x2F;客户端的函数调用关系"></a>（1）TCP 服务器端&#x2F;客户端的函数调用关系</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9vyCPe.png"></p><h3 id="（2）迭代回声服务器-x2F-客户端"><a href="#（2）迭代回声服务器-x2F-客户端" class="headerlink" title="（2）迭代回声服务器&#x2F;客户端"></a>（2）迭代回声服务器&#x2F;客户端</h3><p>程序基本运行方式：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyp5D.png"><br>服务器端(echo_sever.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;++i)    &#123;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             error_handling(&quot;accept() error&quot;);        else            printf(&quot;connect client %d\n&quot;,i+1);        while((str_len&#x3D;read(clnt_sock,message,BUF_SIZE))!&#x3D;0)            write(clnt_sock,message,str_len);        close(clnt_sock);        return 0;    &#125;    close(serv_sock);    return 0;&#125;   void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端(echo_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    while(1)    &#123;        fputs(&quot;input message(Q to quit):&quot;,stdout);        fgets(message,BUF_SIZE,stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;                write(sock,message,strlen(message));        str_len&#x3D;read(sock,message,BUF_SIZE-1);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server %s\n&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回声客户端存在的问题：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyi2d.png"></p><p>修改迭代部分：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyAKI.png"></p><h3 id="（3）计算器服务器端-x2F-客户端示例"><a href="#（3）计算器服务器端-x2F-客户端示例" class="headerlink" title="（3）计算器服务器端&#x2F;客户端示例"></a>（3）计算器服务器端&#x2F;客户端示例</h3><p>客户端设计如下应用层协议：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyP8H.png"></p><p>客户端(op_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define RLT_SIZE 4#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int main(int argc,char *argv[])&#123;    int sock;    char opmsg[BUF_SIZE];    int result,opnd_cnt;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;usage:%s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)        error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error&quot;);    else       fputs(&quot;operand count:&quot;,stdout);       scanf(&quot;%d&quot;,&amp;opnd_cnt);       opmsg[0]&#x3D;(char)opnd_cnt;       for(int i&#x3D;0;i&lt;opnd_cnt;++i)       &#123;        printf(&quot;operand %d:&quot;,i+1);        scanf(&quot;%d&quot;,(int*)&amp;opmsg[i*OPSZ+1]);       &#125;       fgetc(stdin);       fputs(&quot;operator:&quot;,stdout);       scanf(&quot;%c&quot;,&amp;opmsg[opnd_cnt*OPSZ+1]);       write(sock,opmsg,opnd_cnt*OPSZ+2);       read(sock,&amp;result,RLT_SIZE);       printf(&quot;operation result:%d\n&quot;,result);       close(sock);       return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端(op_server.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int calculate(int opnum,int opnds[],char oprator);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char opinfo[BUF_SIZE];    int result,opnd_cnt;    int recv_cnt,recv_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc !&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    if(serv_sock&#x3D;&#x3D;-1)        error_handling(&quot;socket error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1)        error_handling(&quot;listen error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;i++)    &#123;        opnd_cnt&#x3D;0;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr *)&amp;clnt_adr,&amp;clnt_adr_sz);        read(clnt_sock,&amp;opnd_cnt,1);        recv_len&#x3D;0;        while((opnd_cnt*OPSZ+1)&gt;recv_len)        &#123;            recv_cnt&#x3D;read(clnt_sock,&amp;opinfo[recv_len],BUF_SIZE-1);            recv_len+&#x3D;recv_cnt;        &#125;        result&#x3D;calculate(opnd_cnt,(int*)opinfo,opinfo[recv_len-1]);        write(clnt_sock,(char*)&amp;result,sizeof(result));        close(clnt_sock);                &#125;    close(serv_sock);    return 0;&#125;int calculate(int opnum,int opnds[],char op)&#123;    int result&#x3D;opnds[0];    switch(op)    &#123;        case &#39;+&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result+&#x3D;opnds[i];            break;        case &#39;-&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result-&#x3D;opnds[i];            break;        case &#39;*&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result*&#x3D;opnds[i];            break;        case &#39;&#x2F;&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result&#x2F;&#x3D;opnds[i];            break;    &#125;    return result;;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）TCP内部工作原理"><a href="#（4）TCP内部工作原理" class="headerlink" title="（4）TCP内部工作原理"></a>（4）TCP内部工作原理</h3><p>a.与对方套接字的连接（三次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyFxA.png"></p><p>套接字是以全双工（Full-duplex）方式工作的，可以双向传递数据。</p><p>b.与对方主机的数据交换：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyErt.png"></p><p>有超时重传机制</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgLFK.png"></p><p>c.断开与套接字的连接（四次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgfWF.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
