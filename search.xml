<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ primer的阅读笔记</title>
      <link href="/2023/07/12/cpp/"/>
      <url>/2023/07/12/cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）cpp基础"><a href="#（一）cpp基础" class="headerlink" title="（一）cpp基础"></a>（一）cpp基础</h1><h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern。</p><h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><p>定义const变量必须进行初始化。</p><p>不能通过常量引用修改引用对象的值，不能让一个非常量引用指向一个常量。但是初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型（非常量的对象、字面值、一般表达式等）。</p><h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>指针是对象而引用不是，所以指针本身可以是常量，区别于“指向常量的指针”。</p><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>表示指针本身是个常量，底层const指的是所指的对象是个常量。</p><p>或者，顶层const表示任意对象是常量，而底层const则与指针和引用的复合类型的基本类型有关。指针比较特殊，既可以是底层也可以是顶层。</p><blockquote><ul><li>const int *const p3&#x3D;p2;    &#x2F;&#x2F;左底层，右顶层</li><li>const int &amp;r&#x3D;ci;           &#x2F;&#x2F;用于声明引用的const都是底层const</li></ul></blockquote><p>拷贝对象时，顶层const不受什么影响，但是底层const会。拷入拷出对象必须具有相同底层const资格，或者两个对象的数据类必须能相互转换，一般非常量可以转换成常量，反之不行。</p><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p><code>const int sz=get_size();</code>&#x2F;&#x2F;首先，通过函数得到的不是常量，所以它不是常量表达式，其次，具体值要直到运行才能获取，所以不是。</p><h3 id="constexpr变量-（怎么感觉还是迷迷糊糊的？）"><a href="#constexpr变量-（怎么感觉还是迷迷糊糊的？）" class="headerlink" title="constexpr变量 （怎么感觉还是迷迷糊糊的？）"></a>constexpr变量 （怎么感觉还是迷迷糊糊的？）</h3><p>c++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p><p><code>constexpr int sz =size();</code>只有当size是一个constexpr函数时才是正确的声明语句。</p><h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h3><p><code>const int *p=nullptr;</code> p是一个指向整数常量的指针，</p><p><code>constexpr int *q=nullptr;</code> q是一个指向整数的常量指针。</p><h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef char *pstring;const pstring cstr&#x3D;0;&#x2F;&#x2F;cstr是指向char的常量指针const pstring *ps;&#x2F;&#x2F;ps是一个指针，它的对象是指向char的常量指针，不是指向常量的指针！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编译器会以引用对象的类型作为auto的类型，</p><p>auto一般会忽略掉顶层const，同时保留底层const。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i&#x3D;0;const int ci&#x3D;i,&amp;cr&#x3D;ci;auto e&#x3D;&amp;ci;&#x2F;&#x2F;e是一个指向整型常量的指针（对常量取地址是底层const）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>auto &amp;h =42;</code> ❌，不能为非常量引用绑定字面值，<code>const auto &amp;j=42;</code>✔</p><p>设置auto的引用时，初始值中的顶层常量属性仍然保留，如果给初始值绑定一个引用，则此时的常量就不是顶层常量了。（后半句是啥意思啊？）</p><h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int ci&#x3D;0,&amp;cj&#x3D;ci;decltype(ci) x&#x3D;0;&#x2F;&#x2F;x的类型const intdecltype(cj) y&#x3D;x;&#x2F;&#x2F;y的类型const int &amp;decltype(cj) z;&#x2F;&#x2F;❌，引用必须初始化int i&#x3D;42,*p&#x3D;&amp;i,&amp;r&#x3D;i;decltype(r+0) b;&#x2F;&#x2F;b是intdecltype(*p) c;&#x2F;&#x2F;❌，c是int&amp;，必须初始化decltype((i)) d;&#x2F;&#x2F;❌，d是int&amp;，必须初始化（双层括号永远是引用）decltype(i) e;&#x2F;&#x2F;✔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h2><h3 id="string对象和C风格字符串"><a href="#string对象和C风格字符串" class="headerlink" title="string对象和C风格字符串"></a>string对象和C风格字符串</h3><p><code>char *str=s;</code>❌，不能用string对象初始化char*,<code>const char *str=s.c_str();</code>，✔</p><h3 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h3><p>使用范围for语句处理多维数组除了最内层的循环外其他所有循环的控制变量都应该是引用类型，否则编译器初始化会自动将数组形式的元素转换成指向该数组内首元素的指针。</p><h3 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int ia[3][4];int (*p)[4]&#x3D;ia;&#x2F;&#x2F;p指向含有4个整数的数组p&#x3D;&amp;ia[2];&#x2F;&#x2F;p指向ia的尾元素,和auto p&#x3D;ia、auto p&#x3D;begin(ia)一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用类型别名简化多维数组的指针</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using int_array &#x3D;int[4];for(int_array *p&#x3D;ia;p!&#x3D;ia+3;++p)    for(int *q&#x3D;*p;q!&#x3D;*p+4;++q)        cout&lt;&lt;*q&lt;&lt;&#39; &#39;;    cout&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="左值和右值（有点懵，不知有何用）"><a href="#左值和右值（有点懵，不知有何用）" class="headerlink" title="左值和右值（有点懵，不知有何用）"></a>左值和右值（有点懵，不知有何用）</h3><p>当一个对象被用作右值时，用的对象的值（内容）；当对象被用作左值时，用的是对象的身份。</p><h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。</p><p>后置运算符的优先级高于解引用运算符，<code>*pbeg++</code>等于<code>*(pbrg++)</code>，输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。</p><h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p>解引用运算符的优先级低于点运算符。</p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>（迷）</p><p><code>someValue ? ++x, ++y : --x, --y</code>等价于<code>(someValue ? ++x, ++y : --x), --y</code>,逗号表达式的优先级是最低的,如果 someValue的值为真，x 和 y 的值都自增并返回 y 值，然后丢弃 y 值，y递减并返回 y 值。如果 someValue的值为假，x 递减并返回 x 值，然后丢弃 x 值，y递减并返回 y 值。</p><h3 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h3><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>任何有明确定义的类型转换只要不包含底层const，都可以使用，非常适用于把一个较大的算术类型赋值给较小的类型和编译器无法转换的类型。</p><h4 id="const-cast（有点迷）"><a href="#const-cast（有点迷）" class="headerlink" title="const_cast（有点迷）"></a>const_cast（有点迷）</h4><p>只能改变运算对象的底层const，如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>通常为运算对象的位模式提供较低层次上的重新解释。（记住非常危险就对了，没看懂）</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给它（非）常量对象都可以。</p><h3 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h3><p>不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。（所以形参尽量加个const？）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POCO库（线程）</title>
      <link href="/2023/07/06/poco/"/>
      <url>/2023/07/06/poco/</url>
      
        <content type="html"><![CDATA[<h2 id="POCO-C-简介"><a href="#POCO-C-简介" class="headerlink" title="POCO C++简介"></a>POCO C++简介</h2><p>POCO C++包含四个核心库和一些附加库，核心库包括Foundation,XML,Util 和 Net,还有两个附加库，一个是 NetSSL，主要在 Net 库中网络类中提供 SSL 支持；一个是 Date库，在不同的 SQL 库中提供统一的接口访问。</p><h2 id="Foundation库结构"><a href="#Foundation库结构" class="headerlink" title="Foundation库结构"></a>Foundation库结构</h2><p>提供编程时的常用抽象，有18个部分：core,cache,crypt,datetime,events,filesystem,hashing,logging,notifications,processes,regularexpression,sharedlibrary,streams,tasks,text,threading,uri,uuid</p><h1 id="（一）线程"><a href="#（一）线程" class="headerlink" title="（一）线程"></a>（一）线程</h1><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h2><p>如何使用？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Poco&#x2F;Thread.h&quot;#include &quot;Poco&#x2F;Runnable.h&quot;#include&lt;iostream&gt;class HelloRunnable: public Poco::Runnable&#123;    virtual void run()    &#123;        std::cout&lt;&lt;&quot;helloworld&quot;&lt;&lt;std::end;    &#125;&#125;;int main(int argc,char** argv)&#123;    HelloRunnable runnable;    Poco::Thread thread;    thread.start(runnable);    thread.join();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h2><h4 id="在使用之前我们应该充分了解什么是线程池："><a href="#在使用之前我们应该充分了解什么是线程池：" class="headerlink" title="在使用之前我们应该充分了解什么是线程池："></a>在使用之前我们应该充分了解什么是线程池：</h4><p>线程池就是放置线程对象的容器。因为线程会频繁创建、销毁，导致耗费系统资源，所以我们预先创建一系列空线程，在使用线程的时候就直接从线程池里获取IDLE线程，这样的话程序执行起来会变得效率。而长时间运行的线程和需要永久标识和控制线程就不需要使用线程池了。</p><blockquote><p>线程池需要的元素：</p><ul><li>列表，管理多个线程</li><li>线程，自定义具体执行的内容，使用完毕后还能被回收供下次使用</li><li>提供获取空闲（IDLE）线程的方法</li></ul></blockquote><p>Poco的线程池在设计上分为了两层：</p><p>第一层为TheadPool,负责管理线程。从 ThreadPool 的定义看，它是一个 PooledThread 对象的容器。职责分成两部分：第一，维护和管理池属性，如增加线程池线程数目，返回空闲线程数目，结束所有线程。第二，把需要运行的业务委托给 PooledThread 对象，通过接口 start(Runnable&amp; target)</p><p>第二层中 PooledThread 对象为一个在线程池中线程。作为线程池中的线程，其创建于线程池的创建时，销毁于线程池的销毁，生命周期同线程池。在其存活的周期中，状态可分为 running task 和 idle。running 状态为正在运行业务任务，idle 为线程为闲置状态。Poco 中 PooledThread 继承自 Runnable，并且包含一个 Thread 对象。对于 PooledThread 来说，其线程业务就是不断的检测是否有新的外界业务_pTarget，如果有就运行，没有的话，把自己状态标志位限制，供线程池回收。</p><h2 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3.定时器"></a>3.定时器</h2><p>定时器的作用就是预定某个时刻，程序能够得到时间到达的触发信号。</p><p>定时器的使用：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Poco&#x2F;Thread.h&quot;#include &quot;Poco&#x2F;Timer.h&quot;using Poco::Timer;using Poco::TimerCallback;class TimerExample&#123;    public:    void onTimer(Poco::Timer&amp; timer)    &#123;        std::cout&lt;&lt;&quot;onTimer called.&quot;&lt;&lt;std::endl;    &#125;&#125;;int main(int argc,char** argv)&#123;    TimerExample te;    Timer timer(250,500);&#x2F;&#x2F;fire after 250ms,repeat every 500ms    timer.start(TimerCallback&lt;TimerExample(te,&amp;TimerExample::onTimer));    Thread::sleep(5000);    timer.stop();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-主动对象"><a href="#4-主动对象" class="headerlink" title="4.主动对象"></a>4.主动对象</h2><p>首先要了解什么是主动对象：第一它是个对象，第二这个对象使用自己线程运行自己的成员函数。</p><blockquote><ul><li>在 Poco 中，主动对象支持两种主动成员函数。</li><li>Activity 类型的主动对象使用在用户业务为不需要返回值和无参数的成员函数时侯。<br>-ActiveMethod 类型的主动对象使用在用户业务为需要返回值和需要参数的成员函数时侯。</li><li>所有的主动对象即能够共享一个单线程，也可以拥有其自己的线程。</li></ul></blockquote><p>其次，还要了解一个主动对象需要做什么：</p><blockquote><ul><li>线程驱动</li><li>用户真实业务</li></ul></blockquote><h2 id="5-1Acticities"><a href="#5-1Acticities" class="headerlink" title="5.1Acticities"></a>5.1Acticities</h2><p>了解一下它的特性：</p><blockquote><ul><li>Activities 能够在对象构造时自动启动，也能够稍后手动启动</li><li>Activities 能够在任何时候被停止。为了完成这个工作，isStopped()成员函数必须周期性的被调用</li><li>Activities 主动对象运行的成员函数不能够携带参数和返回值</li><li>Activities 的线程驱动来自于默认的线程库</li></ul></blockquote><p>使用例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Poco&#x2F;Activity.h&quot;#include &quot;Poco&#x2F;Thread.h&quot;#include&lt;iostream&gt;using Poco::Thread;class ActivityExample&#123;    public:       ActivityExample() :_activity(this,&amp;ActivityExample::runActivity)&#123;&#125;       void start()       &#123;        _activity.start();       &#125;       void stop()       &#123;        _activity.stop();        _activity.wait();       &#125;    protected:        void runActivity()        &#123;            while(!_activity.isStopped())            &#123;                std::cout&lt;&lt;&quot;Activity running.&quot;&lt;&lt;std::endl;                Thread::sleep(200);            &#125;        &#125;    private:        Poco::Activity&lt;ActivityExample&gt; _activity;&#125;;int main(int argc,char** argv)&#123;    ActivityExample example;    example.start();    Thread::sleep(2000);    example.stop();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2ActiveMethod"><a href="#5-2ActiveMethod" class="headerlink" title="5.2ActiveMethod"></a>5.2ActiveMethod</h2><p>同样，先了解它的特性：</p><blockquote><ul><li>主动对象能够共享一个线程。当一个主动对象运行时，其他的对象等待</li><li>运行业务的成员函数可以拥有一个参数并能返回一个值</li><li>如果函数需要传递更多的参数，可以使用结构体、std::pair、或者 Poco::Tuple</li><li>Active Methods 主动对象的结果由 Poco::ActiveResult 提供</li><li>通常主动对象的函数的返回值不会在调用函数后立刻返回，所以在设计时设计了Poco::ActiveResult类</li><li>ActiveResult 是一个模板类，在函数返回结果时被创建</li><li>ActiveResult 的返回结果可能是一个需要的结果，也可能是一个异常</li><li>使用者通过 ActiveResult::wait()函数等待到结果，通过 ActiveResult::data()获取真<br>实返回值</li></ul></blockquote><p>例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Poco&#x2F;ActiveMethod.h&quot;#include &quot;Poco&#x2F;ActiveResult.h&quot;#include&lt;utility&gt;using Poco::ActiveMethod;using Poco::ActiveResult;class ActiveAdder&#123;    public:        ActiveAdder():            add(this,&amp;ActiveAdder::addImpl)&#123;&#125;            ActiveMethod&lt;int,std::pair&lt;int,int&gt;,ActiveAdder&gt; add;    private:        int addImpl(const std::pair&lt;int,int&gt;&amp;args)        &#123;            return args.first+args.second;        &#125;&#125;;int main(int argc,char** argv)&#123;    ActiveAdder adder;    ActiveResult&lt;int&gt;sum&#x3D;adder.add(std::make_pair(1,2));    sum.wait();    std::cout&lt;&lt;sum.data()&lt;&lt;std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3ActiveDispatcher"><a href="#5-3ActiveDispatcher" class="headerlink" title="5.3ActiveDispatcher"></a>5.3ActiveDispatcher</h2><p>其特性：</p><blockquote><ul><li>ActiveMethod 的默认行为并不符合经典的主动对象概念，经典的主动对象定义要求主动对象支持多个方法，并且各方法能够在单线程中被顺序执行</li><li>为了实现经典主动对象的行为，ActiveDispatcher 被设计成主动对象的基类</li><li>通过使用 ActiveDispatcher 可以顺序执行用户业务函数</li></ul></blockquote><p>例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Poco&#x2F;ActiveMethod.h&quot;#include &quot;Poco&#x2F;ActiveResult.h&quot;#include &quot;Poco&#x2F;ActiveDispatcher.h&quot;#include&lt;utility&gt;using Poco::ActiveMethod;using Poco::ActiveResult;class ActiveAdder::public Poco::ActiveDispatcher&#123;    public:        ActiveObject():            add(this,&amp;ActiveAdder::addImpl)&#123;&#125;            ActiveMethod&lt;int,std::pair&lt;int,int&gt;,ActiveAdder,Poco::ActiveStarter&lt;Poco::ActiveDispatcher&gt;&gt; add;    private:        int addImpl(const std::pair&lt;int,int&gt;&amp;args)        &#123;            return args.first+args.second;        &#125;&#125;;int main(int argc,char** argv)&#123;    ActiveAdder adder;    ActiveResult&lt;int&gt;sum&#x3D;adder.add(std::make_pair(1,2));    sum.wait();    std::cout&lt;&lt;sum.data()&lt;&lt;std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额…文档说不推荐在真实的项目中用主动对象…因为很容易的在 Thread 和 runnable 基础上自己封装<br>一个主动对象，真实业务不需要抽象，业务都是具体的。不使用主动对象的可读性会更加好。</p><h1 id="（二）任务"><a href="#（二）任务" class="headerlink" title="（二）任务"></a>（二）任务</h1><p>简单来看就是一个线程的应用</p><p>Poco中Task的功能：能够自动汇报线程运行进度</p><p>Poco对于任务的描述：</p><blockquote><ul><li>task 主要应用在 GUI 和 Seerver 程序中，用于追踪后台线程的进度</li><li>应用 Poco 任务时，需要类 Poco::Task 和类 Poco::TaskManager 配合使用。其中类Poco::Task 继承自 Poco::Runnable，它提供了接口可以便利的报告线程进度。Poco::TaskManager 则对 Poco::Task 进行管理</li><li>为了完成取消和上报线程进度的工作：</li></ul><ol><li>使用者必须从 Poco::Task 创建一个子类并重写 runTask()函数</li><li>为了完成进度上报的功能，在子类的 runTask()函数中，必须周期的调用setProgress()函数去上报信息</li><li>为了能够在任务运行时终止任务，必须在子类的runTask()函数中，周期性的调用 isCancelled()或者 sleep()函数，去检查是否有任务停止请求</li><li>如果 isCancelled()或者 sleep()返回真，runTask()返回</li></ol><ul><li>Poco::TaskManager 通过使用 Poco::NotificationCenter 去通知所有需要接受任务消息的对象</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POCO库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux高性能服务器编程（一）</title>
      <link href="/2023/06/15/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/06/15/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：热知识：多写注释不会扣钱。</p><h2 id="一、I-x2F-O复用"><a href="#一、I-x2F-O复用" class="headerlink" title="一、I&#x2F;O复用"></a>一、I&#x2F;O复用</h2><p>I&#x2F;O复用能同时监听多个文件描述符，对提高程旭的性能至关重要，通常以下情况需要使用I&#x2F;O复用技术：</p><blockquote><ul><li>客户端程序需要同时处理多个socket，比如非阻塞connect技术</li><li>客户端程序要同时处理多个用户输入和网络连接，比如聊天室程序</li><li>TCP服务器要同时处理监听socket和连接socket</li><li>服务器同时处理TCP请求和UDP请求</li><li>服务器要同时监听多个端口，或者处理多种服务</li></ul></blockquote><h3 id="1-select"><a href="#1-select" class="headerlink" title="1.select"></a>1.select</h3><p>（过多基础概念不多赘述，详见以前文章）<br>由于位操作过于繁琐，使用以下宏来访问fd_set结构体中的位：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys&#x2F;select.h&gt;FD_ZERO(fd_set *fdset);&#x2F;&#x2F;清除fdset所有位FD_SET(int fd,fd_set *fdset);&#x2F;&#x2F;设置FD_CLR(int fd,fd_set *fdset);&#x2F;&#x2F;清除int FD_ISSET(int fd,fd_set *fdset);&#x2F;&#x2F;测试fdset位是否被设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fd_set结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;typesizes.h&gt;#define __FD_SETSIZE 1024#include&lt;sys&#x2F;select.h&gt;#define FD_SETSIZE __FD_SETSIZEtypedef long int __fd_mask;#undef __NFDBITS#define __NFDBITS (8*(int)sizeof(__fd_mask))typedef struct &#123;    #ifdef __USE_XOPEN        __fd_mask fds_bits[__FD_SETSIZE&#x2F;__NFDBITS];    # define __FDS_BITS(set) ((set)-&gt;fds_bits)    #else        __fd_mask __fds_bits[__FD_SETSIZE&#x2F;__NFDBITS];    # define __FDS_BITS(set) ((set)-&gt;__fds_bits)    #endif&#125; fd_set;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-poll系统调用"><a href="#2-poll系统调用" class="headerlink" title="2.poll系统调用"></a>2.poll系统调用</h3><p>和select类似，它指定我们感兴趣的文件描述符上发生的可读可写和异常等事件，原型如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;poll.h&gt;int poll(struct pollfd* fds,nfds_t nfds,int timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="（1）pollfd结构体如下："><a href="#（1）pollfd结构体如下：" class="headerlink" title="（1）pollfd结构体如下："></a>（1）pollfd结构体如下：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct pollfd&#123;    int fd;&#x2F;&#x2F;文件描述符    short events;&#x2F;&#x2F;注册的事件    short revents;&#x2F;&#x2F;实际发生的事件，由内核填充&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>poll支持的类型事件：</p><p><img src="https://s1.ax1x.com/2023/06/22/pCJfmcD.png"></p><p><img src="https://s1.ax1x.com/2023/06/22/pCJfnje.png"></p><p>自Linux内核2.6.17开始，GNU为poll系统调用增加了一个POLLRDHUP事件，它在socket上接收到对方关闭请求连接之后触发，可以区分recv调用返回值是有效数据还是对方关闭请求。使用该事件时需要在代码最开始处定义_GNU_SOURCE。</p><h4 id="2-nfds-t定义："><a href="#2-nfds-t定义：" class="headerlink" title="(2) nfds_t定义："></a>(2) nfds_t定义：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef unsigned long int ndfs_t;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定被监听事件集合fds的大小</p><h4 id="（3）timeout"><a href="#（3）timeout" class="headerlink" title="（3）timeout"></a>（3）timeout</h4><p>poll的超时值，等于-1时poll调用将永远阻塞直到某个事件发生，为0时poll调用将立即返回。</p><h3 id="3-epoll系列系统调用"><a href="#3-epoll系列系统调用" class="headerlink" title="3.epoll系列系统调用"></a>3.epoll系列系统调用</h3><h4 id="（1）内核事件表"><a href="#（1）内核事件表" class="headerlink" title="（1）内核事件表"></a>（1）内核事件表</h4><p>linux特有的I&#x2F;O复用函数：</p><blockquote><ul><li>epoll使用一组函数来完成任务，而不是单个函数</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，不需要像上面两个那样每次调用都要重复的文件描述符或事件集</li><li>epoll需要额外的文件描述符来标识内核中的这个事件表</li></ul></blockquote><p>文件描述符创建：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_create(int size)&#x2F;&#x2F;size参数现在不起作用，只是给内核一个提示告诉它事件表需要多大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>操作epoll内核事件表：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-epoll-wait"><a href="#2-epoll-wait" class="headerlink" title="(2)epoll_wait"></a>(2)epoll_wait</h4><p>(详见以前文章)</p><h4 id="3-LT模式（Level-Trigger，电平触发）和ET模式（Edge-Trigger，边沿触发）"><a href="#3-LT模式（Level-Trigger，电平触发）和ET模式（Edge-Trigger，边沿触发）" class="headerlink" title="(3)LT模式（Level Trigger，电平触发）和ET模式（Edge Trigger，边沿触发）"></a>(3)LT模式（Level Trigger，电平触发）和ET模式（Edge Trigger，边沿触发）</h4><p>当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。LT模式时，epoll_wait检测到其上有事件发生并将通知应用程序后，应用程序不立即处理该事件，下一次调用epoll_wait时，还会向应用程序通告此事件直到该事件被处理。而ET模式检测到事件发生并将此事件通知程序后应用程序必须立即处理该事件，后续调用epoll_wait将不再向应用程序通知这一事件，所以效率要高一点。</p><h4 id="（4）EPOLLONESHOT事件"><a href="#（4）EPOLLONESHOT事件" class="headerlink" title="（4）EPOLLONESHOT事件"></a>（4）EPOLLONESHOT事件</h4><ul><li>对于注册了该事件的文件描述符，操作系统最多触发其上注册的一个可读&#x2F;可写或者异常事件，只触发一次，除非使用epoll_ctl重置。</li><li>如果一个线程或进程在读取完某个socket上的数据后开始处理数据，若过程中又有新数据可读（EPOLLIN再次触发），此时另外一个线程或进程将会被唤醒来读取这些新的数据，就出现了两个线程或进程同时操纵一个socket。</li><li>解决办法可以是在注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就立刻重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，该事件能被触发，进而让其他线程有机会继续处理这个socket。</li></ul><h3 id="4-三组I-x2F-O复用函数的比较"><a href="#4-三组I-x2F-O复用函数的比较" class="headerlink" title="4.三组I&#x2F;O复用函数的比较"></a>4.三组I&#x2F;O复用函数的比较</h3><p><img src="https://s1.ax1x.com/2023/06/22/pCJfMBd.png"></p><h3 id="5-I-x2F-O复用的高级应用一：非阻塞connect"><a href="#5-I-x2F-O复用的高级应用一：非阻塞connect" class="headerlink" title="5.I&#x2F;O复用的高级应用一：非阻塞connect"></a>5.I&#x2F;O复用的高级应用一：非阻塞connect</h3><p>在对非阻塞的socket调用connect，而连接又没有立即建立时，会发生EINRROGRESS错误❌。我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsocket来读取错误码并清除该socket上的错误。错误码0表示成功建立，否则连接失败。通过上述非阻塞connect方式，就能同时发起多个连接并一起等待。但该方法存在几处移植性问题，首先非阻塞的socket可能导致connect始终失败，其次select对于EINPROGRESS状态下的socket可能不起作用，最后对于出错的socket，getsockopt在有些系统上返回-1（比如Linux），而有些（Unix）返回0。</p><h3 id="6-I-x2F-O复用的高级应用二：聊天室程序"><a href="#6-I-x2F-O复用的高级应用二：聊天室程序" class="headerlink" title="6.I&#x2F;O复用的高级应用二：聊天室程序"></a>6.I&#x2F;O复用的高级应用二：聊天室程序</h3><p>该聊天室能让所有用户同时在线群聊。客户端从标准输入终端读入用户数据并将用户数据发送至服务器，往标准输出终端打印服务器发送给它的数据。服务器接收客户端数据，并把客户数据发送给每一个登录到该服务器上的客户端。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*客户端使用poll同时监听用户输入和网络连接，并利用splice函数将用户输入的内容直接定向到网络连接上以发送，从而实现数据零拷贝，提高程序执行效率*&#x2F;#define _GNU_SOURCE 1#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;netinet&#x2F;in.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;assert.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;poll.h&gt;#include&lt;fcntl.h&gt;#define BUFFER_SIZE 64int main(int argc,char* argv[])&#123;    if(argc&lt;&#x3D;2)     &#123;        printf(&quot;Usage: %s ip_address port_number\n&quot;, basename(argv[0]));        return 1;    &#125;    const char* ip&#x3D;argv[1];    int port&#x3D;atoi(argv[2]);    struct sockaddr_in server_address;    bzero(&amp;server_address, sizeof(server_address));    server_address.sin_family&#x3D;AF_INET;    inet_pton(AF_INET,ip,&amp;server_address.sin_addr);    server_address.sin_port&#x3D;htons(port);    int sockfd&#x3D;socket(PF_INET,SOCK_STREAM,0);    assert(sockfd&gt;&#x3D;0);    if(connect(sockfd,(struct sockaddr*)&amp;server_address,sizeof(server_address))&lt;0)    &#123;        printf(&quot;connect failed\n&quot;);        close(sockfd);        return 1;    &#125;    struct pollfd fds[2];    &#x2F;&#x2F;注册文件描述符0(标准输入)和文件描述符sockfd上的可读事件    fds[0].fd&#x3D;0;    fds[0].events&#x3D;POLLIN;    fds[0].revents&#x3D;0;    fds[1].fd&#x3D;sockfd;    fds[1].events&#x3D;POLLIN | POLLRDHUP;    fds[1].revents&#x3D;0;    char read_buf[BUFFER_SIZE];    int pipefd[2];    int ret&#x3D;pipe(pipefd);    assert(ret!&#x3D;-1);    while(1)    &#123;        ret&#x3D;poll(fds,2,-1);        if(ret&lt;0)        &#123;            printf(&quot;poll failed\n&quot;);            break;        &#125;        if(fds[1].revents &amp; POLLRDHUP)        &#123;            printf(&quot;server close the connection\n&quot;);            break;        &#125;        else if(fds[1].revents &amp; POLLIN)        &#123;            memset(read_buf,&#39;\0&#39;,BUFFER_SIZE);            recv(fds[1].fd,read_buf,BUFFER_SIZE-1,0);            printf(&quot;%s\n&quot;,read_buf);        &#125;&#x2F;&#x2F;把内容输出到控制台        if(fds[0].revents &amp; POLLIN)        &#123;            &#x2F;&#x2F;使用splice将用户输入的数据直接写到sockfd上            ret&#x3D;splice(0,NULL,pipefd[1],NULL,32768,SPLICE_F_MORE | SPLICE_F_MOVE);            ret&#x3D;splice(pipefd[0],NULL,sockfd,NULL,32768,SPLICE_F_MORE | SPLICE_F_MOVE);        &#125;    &#125;    close(sockfd);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*服务端程序使用poll同时监听socket和连接socket，并且使用牺牲空间换取时间的策略提高服务器性能*&#x2F;#define _GNU_SOURCE 1#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;netinet&#x2F;in.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;assert.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;poll.h&gt;#include&lt;fcntl.h&gt;#include&lt;errno.h&gt;#define BUFFER_SIZE 64#define USER_LIMIT 5#define FD_LIMIT 65535&#x2F;&#x2F;文件描述符数量限制&#x2F;&#x2F;客户端数据：客户端socket地址，代写到客户端的数据位置，从客户端读入的数据struct client_data&#123;    struct sockaddr_in address;    char* write_buf;    char buf[BUFFER_SIZE];&#125;;int setnonblocking(int fd)&#123;    int old_option&#x3D;fcntl(fd,F_GETFL);    int new_option&#x3D;old_option | O_NONBLOCK;    fcntl(fd,F_SETFL,new_option);    return old_option;&#125;int main(int argc,char* argv[])&#123;    if(argc&lt;&#x3D;2)     &#123;        printf(&quot;Usage: %s ip_address port_number\n&quot;, basename(argv[0]));        return 1;    &#125;    const char* ip&#x3D;argv[1];    int port&#x3D;atoi(argv[2]);    int ret;    struct sockaddr_in address;    bzero(&amp;address,sizeof(address));    address.sin_family&#x3D;AF_INET;    inet_pton(AF_INET,ip,&amp;address.sin_addr);    address.sin_port&#x3D;htons(port);    int listenfd&#x3D;socket(PF_INET,SOCK_STREAM,0);    assert(listenfd&gt;&#x3D;0);    ret&#x3D;bind(listenfd,(struct sockaddr*)&amp;address,sizeof(address));    assert(ret!&#x3D;-1);    ret&#x3D;listen(listenfd,5);    assert(ret!&#x3D;-1);    &#x2F;*创建users数组，分配FD_LIMIT个client_data对象，    可以预期：每个可能的socket连接都可以获得一个这样的对象，    并且socket的值可以直接用来索引socket连接对应的client_data对象，    这是将socket和客户数据关联的简单而高效的方法*&#x2F;    client_data* users&#x3D;new client_data[FD_LIMIT];    &#x2F;&#x2F;尽管分配了足够多的client_data对象，但为了提高poll的性能，有必要限制用户数量    pollfd fds[USER_LIMIT+1];    int user_counter&#x3D;0;    for(int i&#x3D;0; i&lt;USER_LIMIT; i++)    &#123;        fds[i].fd&#x3D;-1;        fds[i].events&#x3D;0;    &#125;    fds[0].fd&#x3D;listenfd;    fds[0].events&#x3D;POLLIN | POLLERR;    fds[0].revents&#x3D;0;    while(1)    &#123;        ret&#x3D;poll(fds,user_counter+1,-1);        if(ret&lt;0)        &#123;            printf(&quot;poll failed\n&quot;);            break;        &#125;        for(int i&#x3D;0;i&lt;user_counter+1;++i)        &#123;            if((fds[i].fd&#x3D;&#x3D;listenfd)&amp;&amp;(fds[i].revents&amp;POLLIN))            &#123;                struct sockaddr_in client_addr;                socklen_t client_addr_len&#x3D;sizeof(client_addr);                int connfd&#x3D;accept(listenfd,(struct sockaddr*)&amp;client_addr,&amp;client_addr_len);                if(connfd&lt;0)                &#123;                    printf(&quot;errno is:%d\n&quot;,errno);                    continue;                &#125;                &#x2F;&#x2F;如果请求太多则关闭新到的连接                if(user_counter&gt;&#x3D;USER_LIMIT)                &#123;                    const char* info&#x3D;&quot;too much users\n&quot;;                    printf(&quot;%s&quot;,info);                    send(connfd,info,strlen(info),0);                    close(connfd);                    continue;                &#125;                &#x2F;&#x2F;对于新连接，同时修改fds和users数组                user_counter++;                users[connfd].address&#x3D;client_addr;                setnonblocking(connfd);                fds[user_counter].fd&#x3D;connfd;                fds[user_counter].events&#x3D;POLLIN | POLLRDHUP | POLLERR;                fds[user_counter].revents&#x3D;0;                printf(&quot;here comes a new user,now %d users\n&quot;,user_counter);            &#125;            else if(fds[i].revents &amp; POLLERR)            &#123;                printf(&quot;get an error from %d\n&quot;,fds[i].fd);                char errors[100];                memset(errors, 0, sizeof(errors));                socklen_t length&#x3D;sizeof(errors);                if(getsockopt(fds[i].fd,SOL_SOCKET,SO_ERROR,&amp;errors,&amp;length)&lt;0)                &#123;                    printf(&quot;get socket option failed\n&quot;);                &#125;                continue;            &#125;            else if(fds[i].revents &amp;POLLRDHUP)            &#123;                &#x2F;&#x2F;如果客户端关闭连接，则服务端也关闭对应的连接，用户数-1                users[fds[i].fd]&#x3D;users[fds[user_counter].fd];                close(fds[i].fd);                fds[i]&#x3D;fds[user_counter];                i--;                user_counter--;                printf(&quot;a client left\n&quot;);            &#125;            else if(fds[i].revents&amp; POLLIN)            &#123;                int connfd&#x3D;fds[i].fd;                memset(users[connfd].buf,0,BUFFER_SIZE);                ret&#x3D;recv(connfd,users[connfd].buf,BUFFER_SIZE-1,0);                printf(&quot;get %d bytes of client data %s from %d\n&quot;,ret,users[connfd].buf,connfd);                if(ret&lt;0)                &#123;                    if(errno!&#x3D;EAGAIN)                    &#123;                        close(connfd);                        users[fds[i].fd]&#x3D;users[fds[user_counter].fd];                        fds[i]&#x3D;fds[user_counter];                        i--;                        user_counter--;                    &#125;                &#125;                else if(ret &#x3D;&#x3D; 0)                &#123;                &#125;                else                &#123;                    for(int j&#x3D;0;j&lt;&#x3D;user_counter;++j)                    &#123;                        if(fds[j].fd&#x3D;&#x3D;connfd)                        &#123;                            continue;                        &#125;                        fds[j].events|&#x3D;~POLLIN;                        fds[j].events|&#x3D;POLLIN;                        users[fds[j].fd].write_buf&#x3D;users[connfd].buf;                    &#125;                &#125;            &#125;            else if(fds[i].revents &amp; POLLOUT)            &#123;                int connfd&#x3D;fds[i].fd;                if(!users[connfd].write_buf)                &#123;                    continue;                &#125;                ret&#x3D;send(connfd,users[connfd].write_buf,strlen(users[connfd].write_buf),0);                users[connfd].write_buf&#x3D;NULL;                fds[i].events|&#x3D;~POLLOUT;                fds[i].events|&#x3D;POLLOUT;            &#125;        &#125;    &#125;    delete[]users;    close(listenfd);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、信号"><a href="#二、信号" class="headerlink" title="二、信号"></a>二、信号</h2><h3 id="1-发送信号"><a href="#1-发送信号" class="headerlink" title="1.发送信号"></a>1.发送信号</h3><p>Linux下一个进程给其他进程发送信号的API是kill函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys&#x2F;types.h&gt;#include&lt;signal.h&gt;int kill(pid_t pid,int sig);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/22/pCJfEh6.png"></p><h3 id="2-信号函数"><a href="#2-信号函数" class="headerlink" title="2.信号函数"></a>2.信号函数</h3><p>（基础部分翻以前的文章）</p><p>sigaction结构体中sa_flags选项：</p><p><img src="https://s1.ax1x.com/2023/06/22/pCJfZ9K.png"></p><h3 id="3-信号集"><a href="#3-信号集" class="headerlink" title="3.信号集"></a>3.信号集</h3><h4 id="1-函数"><a href="#1-函数" class="headerlink" title="(1)函数"></a>(1)函数</h4><p>Linux使用数据结构sigset_t来表示一组信号,sigset_t实际上是一组长整型数组，数组的每个位表示一个信号，有点和fd_set类似。linux提供以下一组函数来设置、修改、删除和查询信号集：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;int sigemptyset (sigset_t* _set)int sigfillset (sigset_t* _set)int sigaddset (sigset_t* _set,int _signo)int sigdelset (sefset_t* _set,int _signo)int sigismenber (_const sigset_t,int _signo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）进程信号掩码"><a href="#（2）进程信号掩码" class="headerlink" title="（2）进程信号掩码"></a>（2）进程信号掩码</h4><p>可以利用sigaction结构体的sa_mask来设置进程的信号掩码。此外，以下函数也可以用于设置或查看进程的信号掩码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;int sigprocmask(int _how,_constnsigset_t* _set,sigset_t* _oset);&#x2F;&#x2F;_set指定新的信号掩码，_oset参数则输出原来的信号掩码（不为NULL的话）。如果_set不为NULL，则_how参数指定设置进程信号掩码的方式，其可选值如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/22/pCJfe1O.png"></p><p>如果_set为NULL，则进程信号掩码不变，此时仍可以用_oset参数来获得进程当前的信号掩码。成返0，败-1并设置errno</p><h4 id="3-被挂起的信号"><a href="#3-被挂起的信号" class="headerlink" title="(3)被挂起的信号"></a>(3)被挂起的信号</h4><p><img src="https://s1.ax1x.com/2023/06/22/pCJfKnH.png"></p><p>set参数用于保存被挂起的信号集，进程即使多次接收到同一个被挂起的信号，sigpending函数也只能反映一次，并且再次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只能被触发一次。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（五）</title>
      <link href="/2023/06/05/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/"/>
      <url>/2023/06/05/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</url>
      
        <content type="html"><![CDATA[<h2 id="13-epoll"><a href="#13-epoll" class="headerlink" title="13.epoll"></a>13.epoll</h2><p>select复用无论如何优化程序性能也无法同时接入上百个客户，所以并不适合web服务器端开发为主流的现代开发环境，所以要学习Linux平台下的epoll。</p><h3 id="（1）epoll必要的函数和结构体"><a href="#（1）epoll必要的函数和结构体" class="headerlink" title="（1）epoll必要的函数和结构体"></a>（1）epoll必要的函数和结构体</h3><p>epoll方式通过如下结构体将发生变化的文件描述符单独集中在一起：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct epoll_event&#123;    __uint32_t events;    epoll_data_t data;&#125;        typedef union epoll_data        &#123;            void * ptr;            int fd;            __uint32_t u32;            __uint64_t u64;        &#125;epoll_data_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>epoll_event的成员events中可以保存的常量及所指的事件类型：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXaZj.png"></p><p><strong>epoll_create</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_create(int size);&#x2F;&#x2F;成epoll文件描述符，败-1&#x2F;&#x2F;size，epoll实例大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>epoll_ctl</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_ctl(int epfd,int op,int fd,struct epoll_event * event);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXDJ0.png"></p><p>第二个参数传递的常量及含义：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXdds.png"></p><p><strong>epoll_wait</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;epoll.h&gt;int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);&#x2F;&#x2F;成返回发生事件的文件描述符，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXtsg.png"></p><h3 id="（2）基于epoll的回声服务器端"><a href="#（2）基于epoll的回声服务器端" class="headerlink" title="（2）基于epoll的回声服务器端"></a>（2）基于epoll的回声服务器端</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#define BUF_SIZE 100#define EPOLL_SIZE 50void error_handling(char * buf);int main(int argc, char * argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t adr_sz;    int str_len;    char buf[BUF_SIZE];    struct epoll_event *ep_events;    struct epoll_event event;    int epfd,event_cnt;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htons(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    epfd&#x3D;epoll_create(EPOLL_SIZE);    ep_events&#x3D;malloc(sizeof(struct epoll_event)*EPOLL_SIZE);    event.events&#x3D;EPOLLIN;    event.data.fd&#x3D;serv_sock;    epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event);    while(1)    &#123;        event_cnt&#x3D;epoll_wait(epfd,ep_events,EPOLL_SIZE,-1);        if(event_cnt&#x3D;&#x3D;-1)        &#123;            puts(&quot;epoll_wait error&quot;);            break;        &#125;        for(int i&#x3D;0;i&lt;event_cnt;++i)        &#123;            if(ep_events[i].data.fd&#x3D;&#x3D;serv_sock)            &#123;                adr_sz&#x3D;sizeof(clnt_adr);                clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                event.events&#x3D;EPOLLIN;                event.data.fd&#x3D;clnt_sock;                epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event);                printf(&quot;connected client:%d\n&quot;,clnt_sock);            &#125;            else&#123;                str_len&#x3D;read(ep_events[i].data.fd,buf,BUF_SIZE);                if(str_len&#x3D;&#x3D;0)                &#123;                    epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL);                    close(ep_events[i].data.fd);                    printf(&quot;closed client:%d\n&quot;,ep_events[i].data.fd);                &#125;                else&#123;                    write(ep_events[i].data.fd,buf,str_len);                &#125;            &#125;        &#125;            &#125;    close(serv_sock);            close(epfd);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-实现边缘触发的回声服务器端"><a href="#3-实现边缘触发的回声服务器端" class="headerlink" title="(3)实现边缘触发的回声服务器端"></a>(3)实现边缘触发的回声服务器端</h3><p>边缘触发方式中，接收数据时仅注册一次该事件，一旦发生输入相关事件，就应该读取输入缓冲中全部数据，因此需要验证输入缓冲是否为空。read函数返回-1，变量errno中的值为EAGAIN时，说明没有数据可读。需要套接字变成非阻塞方式，否则以阻塞方式共做的read&amp;write函数可能引起服务器端长时间停顿。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;fcntl.h&gt;#include&lt;errno.h&gt;#define BUF_SIZE 4#define EPOLL_SIZE 50void setnonblockingmode(int fd);void error_handling(char * buf);int main(int argc, char * argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t adr_sz;    int str_len;    char buf[BUF_SIZE];    struct epoll_event *ep_events;    struct epoll_event event;    int epfd,event_cnt;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htons(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    epfd&#x3D;epoll_create(EPOLL_SIZE);    ep_events&#x3D;malloc(sizeof(struct epoll_event)*EPOLL_SIZE);    event.events&#x3D;EPOLLIN;    event.data.fd&#x3D;serv_sock;    epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event);    while(1)    &#123;        event_cnt&#x3D;epoll_wait(epfd,ep_events,EPOLL_SIZE,-1);        if(event_cnt&#x3D;&#x3D;-1)        &#123;            puts(&quot;epoll_wait error&quot;);            break;        &#125;        puts(&quot;return epoll_wait&quot;);        for(int i&#x3D;0;i&lt;event_cnt;++i)        &#123;            if(ep_events[i].data.fd&#x3D;&#x3D;serv_sock)            &#123;                adr_sz&#x3D;sizeof(clnt_adr);                clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                setnonblockingmode(clnt_sock);                event.events&#x3D;EPOLLIN|EPOLLET;                event.data.fd&#x3D;clnt_sock;                epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event);                printf(&quot;connected client:%d\n&quot;,clnt_sock);            &#125;            else&#123;                while(1)                &#123;                    str_len&#x3D;read(ep_events[i].data.fd,buf,BUF_SIZE);                    if(str_len&#x3D;&#x3D;0)                    &#123;                        epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL);                        close(ep_events[i].data.fd);                        printf(&quot;closed client:%d\n&quot;,ep_events[i].data.fd);                        break;                    &#125;                    else if(str_len&lt;0)                    &#123;                        if(errno&#x3D;&#x3D;EAGAIN)                            break;                    &#125;                    else&#123;                        write(ep_events[i].data.fd,buf,str_len);                    &#125;                 &#125;                            &#125;        &#125;            &#125;    close(serv_sock);    close(epfd);    return 0;&#125;void setnonblockingmode(int fd)&#123;    int flag&#x3D;fcntl(fd,F_GETFL,0);    fcntl(fd,F_SETFL,flag|O_NONBLOCK);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-多线程服务器端的实现"><a href="#14-多线程服务器端的实现" class="headerlink" title="14.多线程服务器端的实现"></a>14.多线程服务器端的实现</h2><h3 id="（1）线程和进程的差异："><a href="#（1）线程和进程的差异：" class="headerlink" title="（1）线程和进程的差异："></a>（1）线程和进程的差异：</h3><p>进程间独立的内存：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXYQS.png"></p><p>线程的内存结构：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXNLQ.png"></p><h3 id="（2）线程创建和运行"><a href="#（2）线程创建和运行" class="headerlink" title="（2）线程创建和运行"></a>（2）线程创建和运行</h3><p>线程具有单独的执行流，因此需要单独定义线程的main函数，还需请求操作系统在单独的执行流中执行该函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_create(    pthread_t * restrict thread,const pthread_attr_t * restrict attr,    void  * (* start_routine)(void *),void * restrict arg);&#x2F;&#x2F;成0，败返回其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXNLQ.png"></p><p>通过下列代码了解该函数的功能：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;void* thread_main(void *arg);int main(int argc,char *argv[])&#123;    pthread_t t_id;    int thread_param&#x3D;5;    if(pthread_create(&amp;t_id,NULL,thread_main,(void*)&amp;thread_param)!&#x3D;0)    &#123;        puts(&quot;pthread_create() error&quot;);        return -1;    &#125;    sleep(10);    puts(&quot;end of main&quot;);    return 0;&#125;void* thread_main(void * arg)&#123;    int cnt&#x3D;*((int*)arg);    for(int i&#x3D;0;i&lt;cnt;++i)    &#123;        sleep(1);puts(&quot;running thread&quot;);    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXwon.png"></p><p>执行流程：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCXrWV.png"></p><p>将sleep（10）改为sleep（2）将不会输出5次running thread，因为main函数返回后整个进程将被销毁。通常利用下面的函数控制线程的执行流：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_join(pthread_t thread,void ** status);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;thread  该参数id的线程终止后才会从该函数返回&#x2F;&#x2F;status 保存线程的main函数返回值的指针变量地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;void* thread_main(void *arg);int main(int argc,char *argv[])&#123;    pthread_t t_id;    int thread_param&#x3D;5;    void * thr_ret;    if(pthread_create(&amp;t_id,NULL,thread_main,(void*)&amp;thread_param)!&#x3D;0)    &#123;        puts(&quot;pthread_create() error&quot;);        return -1;    &#125;    if(pthread_join(t_id,&amp;thr_ret)!&#x3D;0)    &#123;        puts(&quot;pthread_join() error&quot;);        return -1;    &#125;    printf(&quot;pthread return message:%s\n&quot;,(char*)thr_ret);    free(thr_ret);    return 0;&#125;void* thread_main(void * arg)&#123;    int cnt&#x3D;*((int*)arg);    char * msg&#x3D;(char*)malloc(sizeof(char)*50);    strcpy(msg,&quot;hello,I&#39;m thread~\n&quot;);    for(int i&#x3D;0;i&lt;cnt;++i)    &#123;        sleep(1);puts(&quot;running thread&quot;);    &#125;    return (void*)msg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流程图：</p><p><img src="https://s1.ax1x.com/2023/06/05/pCCX6QU.png"></p><h3 id="（3）互斥量"><a href="#（3）互斥量" class="headerlink" title="（3）互斥量"></a>（3）互斥量</h3><p><strong>创建及销毁</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t * attr);int pthread_mutex_destroy(pthread_mutex_t * mutex);&#x2F;&#x2F;成0，败其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXszT.png"></p><p><strong>互斥量锁住或释放临界区时使用的函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);&#x2F;&#x2F;成0，败返回其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）信号量"><a href="#（4）信号量" class="headerlink" title="（4）信号量"></a>（4）信号量</h3><p><strong>创建及销毁</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;semaphore.h&gt;int sem_init(sem_t *sem,int pshared,unsigned int value);int sem_destroy(sem_t *sem);&#x2F;&#x2F;成0，败其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/05/pCCXcyF.png"></p><p><strong>下面函数相当于互斥量的lock和unlock函数：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;semaphore.h&gt;int sem_post(sem_t * sem);int sem_wait(sem_t * sem);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;sem，传递信号量读取值的变量地址值，传递给sem_post时信号量增1，反之-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（5）线程的销毁和多线程并发服务器端的实现"><a href="#（5）线程的销毁和多线程并发服务器端的实现" class="headerlink" title="（5）线程的销毁和多线程并发服务器端的实现"></a>（5）线程的销毁和多线程并发服务器端的实现</h3><p>调用pthread_join函数时，不仅会等待线程种植，还会引导线程销毁。但线程终止前调用该函数的线程将进入阻塞状态。因此通常通过如下函数调用引导线程销毁：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;pthread.h&gt;int pthread_detach(pthread_t thread);&#x2F;&#x2F;成0，败其他值&#x2F;&#x2F;thread，终止时同时需要销毁的线程id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>聊天程序服务器端：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 100#define MAX_CLNT 256void * handle_clnt(void *arg);void send_msg(char * msg,int len);void error_handling(char * message);int clnt_cnt&#x3D;0;int clnt_socks[MAX_CLNT];pthread_mutex_t mutex;int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int clnt_adr_sz;    pthread_t t_id;    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s &lt;port&gt;\n&quot;, argv[0]);        exit(1);    &#125;    pthread_mutex_init(&amp;mutex,NULL);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) error_handling(&quot;listen error&quot;);    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_sock,&amp;clnt_adr_sz);        pthread_mutex_lock(&amp;mutex);        clnt_socks[clnt_cnt++]&#x3D;clnt_sock;        pthread_mutex_unlock(&amp;mutex);        pthread_create(&amp;t_id,NULL,handle_clnt,(void*)&amp;clnt_sock);        pthread_detach(t_id);        printf(&quot;connected client IP :%s\n&quot;,inet_ntoa(clnt_adr.sin_addr));    &#125;    close(serv_sock);    return 0;&#125;void * handle_clnt(void *arg)&#123;    int clnt_sock&#x3D;*((int*)arg);    int str_len&#x3D;0;    char msg[BUF_SIZE];    while((str_len&#x3D;read(clnt_sock,msg,sizeof(msg)))!&#x3D;0)        send_msg(msg,str_len);    pthread_mutex_lock(&amp;mutex);    for(int i&#x3D;0;i&lt;clnt_cnt;++i)    &#123;        if(clnt_sock&#x3D;&#x3D;clnt_socks[i])        &#123;            while(i++&lt;clnt_cnt-1)                clnt_socks[i]&#x3D;clnt_socks[i+1];            break;        &#125;    &#125;    clnt_cnt--;    pthread_mutex_unlock(&amp;mutex);    close(clnt_sock);    return NULL;&#125;void send_msg(char *msg,int len)&#123;    pthread_mutex_lock(&amp;mutex);    for(int i&#x3D;0;i&lt;clnt_cnt;++i)    &#123;        write(clnt_socks[i],msg,len);    &#125;    pthread_mutex_unlock(&amp;mutex);&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>聊天程序客户端：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;sys&#x2F;epoll.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 100#define NAME_SIZE 20void * send_msg(void * arg);void * recv_msg(void * arg);void error_handling(char *msg);char name[NAME_SIZE]&#x3D;&quot;[DEFAULT]&quot;;char msg[BUF_SIZE];int main(int argc,char *argv[])&#123;    int sock;    struct sockaddr_in serv_addr;    pthread_t snd_thread,rcv_thread;    void * thread_return;    if(argc!&#x3D;4)    &#123;        printf(&quot;Usage:%s&lt;ip&gt;&lt;port&gt;&lt;name&gt;\n&quot;, argv[0]);        exit(1);    &#125;    sprintf(name,&quot;[%s]&quot;,argv[3]);    sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    memset(&amp;serv_addr,0,sizeof(serv_addr));    serv_addr.sin_family &#x3D; AF_INET;    serv_addr.sin_addr.s_addr &#x3D;inet_addr(argv[1]);    serv_addr.sin_port &#x3D; htons(atoi(argv[2]));    if(connect(sock, (struct sockaddr *)&amp;serv_addr,sizeof(serv_addr))&#x3D;&#x3D;-1)        error_handling(&quot;connect error&quot;);     pthread_create(&amp;snd_thread, NULL,send_msg,(void*)&amp;sock);    pthread_create(&amp;rcv_thread, NULL,recv_msg,(void*)&amp;sock);    pthread_join(snd_thread, &amp;thread_return);    pthread_join(rcv_thread, &amp;thread_return);    close(sock);    return 0;&#125;void * send_msg(void * arg)&#123;    int sock&#x3D;*((int*)arg);    char name_msg[NAME_SIZE+BUF_SIZE];    while(1)    &#123;        fgets(msg,BUF_SIZE,stdin);        if(!strcmp(msg,&quot;q\n&quot;)||!strcmp(msg,&quot;Q\n&quot;))        &#123;            close(sock);            exit(0);        &#125;        sprintf(name_msg,&quot;%s %s&quot;,name,msg);        write(sock,name_msg,strlen(name_msg));    &#125;    return NULL;&#125;void * recv_msg(void * arg)&#123;    int sock&#x3D;*((int*)arg);    char name_msg[NAME_SIZE+BUF_SIZE];    int str_len;    while(1)    &#123;        str_len&#x3D;read(sock,name_msg,NAME_SIZE+BUF_SIZE-1);        if(str_len&#x3D;&#x3D;-1) return (void*)-1;        name_msg[str_len]&#x3D;0;        fputs(name_msg,stdout);    &#125;    return NULL;&#125;void error_handling(char *buf)&#123;    fputs(buf,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-HTTP服务器端"><a href="#15-HTTP服务器端" class="headerlink" title="15.HTTP服务器端"></a>15.HTTP服务器端</h2><h3 id="（1）了解HTTP协议"><a href="#（1）了解HTTP协议" class="headerlink" title="（1）了解HTTP协议"></a>（1）了解HTTP协议</h3><p>请求&#x2F;响应过程：</p><p>服务武器不会维持客户端状态，称为无状态的Stateless协议</p><p><img src="https://s1.ax1x.com/2023/06/14/pCnlCcD.png"></p><h4 id="请求消息的结构"><a href="#请求消息的结构" class="headerlink" title="请求消息的结构"></a>请求消息的结构</h4><p><img src="https://s1.ax1x.com/2023/06/14/pCnlFnH.png"></p><h4 id="响应消息的结构"><a href="#响应消息的结构" class="headerlink" title="响应消息的结构"></a>响应消息的结构</h4><p><img src="https://s1.ax1x.com/2023/06/14/pCnl91O.png"></p><h3 id="（2）实现Web服务器端"><a href="#（2）实现Web服务器端" class="headerlink" title="（2）实现Web服务器端"></a>（2）实现Web服务器端</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;pthread.h&gt;#define BUF_SIZE 1024#define SMALL_BUF 100void * request_handler(void *arg);void send_data(FILE *fp,char *ct,char *file_name);char *content_type(char *file);void send_error(FILE *fp);int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int clnt_adr_size;    char buf[BUF_SIZE];    pthread_t t_id;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;, argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    memset(&amp;serv_adr, 0, sizeof(serv_adr));    serv_adr.sin_family &#x3D; AF_INET;    serv_adr.sin_addr.s_addr &#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1) printf(&quot;bind error&quot;);    if(listen(serv_sock,20)&#x3D;&#x3D;-1) printf(&quot;listen error&quot;);    while(1)    &#123;        clnt_adr_size&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_size);        printf(&quot;connection request:%s:%d\n&quot;,        inet_ntoa(clnt_adr.sin_addr),ntohs(clnt_adr.sin_port));        pthread_create(&amp;t_id,NULL,request_handler,&amp;clnt_sock);        pthread_detach(t_id);    &#125;    close(serv_sock);    return 0;&#125;void* request_handler(void* arg)&#123;    int clnt_sock&#x3D;*((int*)arg);    char req_line[SMALL_BUF];    FILE* clnt_read;    FILE* clnt_write;    char method[10];    char ct[15];    char file_name[30];    clnt_read&#x3D;fdopen(clnt_sock,&quot;r&quot;);    clnt_write&#x3D;fdopen(dup(clnt_sock),&quot;w&quot;);    fgets(req_line,SMALL_BUF,clnt_read);    if(strstr(req_line,&quot;HTTP&#x2F;&quot;)&#x3D;&#x3D;NULL)    &#123;        send_error(clnt_write);        fclose(clnt_read);        fclose(clnt_write);        &#x2F;&#x2F; return;    &#125;    strcpy(method,strtok(req_line,&quot; &#x2F;&quot;));    strcpy(file_name,strtok(NULL,&quot; &#x2F;&quot;));    strcpy(ct,content_type(file_name));    if(strcmp(method,&quot;GET&quot;)!&#x3D;0)    &#123;        send_error(clnt_write);        fclose(clnt_read);        fclose(clnt_write);        &#x2F;&#x2F; return;    &#125;    fclose(clnt_read);    send_data(clnt_write,ct,file_name);&#125;void send_data(FILE *fp,char *ct, char *file_name)&#123;    char protocol[]&#x3D;&quot;HTTP&#x2F;1.0 200 OK\r\n&quot;;    char server[]&#x3D;&quot;Server:Linux Web Server\r\n&quot;;    char cnt_len[]&#x3D;&quot;Content-length:2048\r\n&quot;;    char cnt_type[SMALL_BUF];    char buf[BUF_SIZE];    FILE *send_file;    sprintf(cnt_type,&quot;Content-type:%s\r\n\r\n&quot;,ct);    send_file&#x3D;fopen(file_name,&quot;r&quot;);    if(send_file&#x3D;&#x3D;NULL)    &#123;        send_error(fp);        return;    &#125;    fputs(protocol,fp);    fputs(server,fp);    fputs(cnt_len,fp);    fputs(cnt_type,fp);    while(fgets(buf,BUF_SIZE,send_file)!&#x3D;NULL)    &#123;        fputs(buf,fp);        fflush(fp);    &#125;&#125;char * content_type(char* file)&#123;    char extension[SMALL_BUF];    char file_name[SMALL_BUF];    strcpy(file_name,file);    strtok(file_name,&quot;.&quot;);    strcpy(extension,strtok(NULL,&quot;.&quot;));    if(!strcmp(extension,&quot;html&quot;)|| !strcmp(extension,&quot;htm&quot;))        return &quot;text&#x2F;html&quot;;    else        return &quot;text&#x2F;plain&quot;;&#125;void send_error(FILE *fp)&#123;    char protocol[]&#x3D;&quot;HTTP&#x2F;1.0 400 Bad Request\r\n&quot;;    char server[]&#x3D;&quot;Server:Linux Web Server\r\n&quot;;    char cnt_len[]&#x3D;&quot;Content_Length:2048\r\n&quot;;    char cnt_type[]&#x3D;&quot;Content-Type:text&#x2F;html\r\n\r\n&quot;;    char content[]&#x3D;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&quot;        &quot;&lt;body&gt;&lt;front size&#x3D;+5&lt;br&gt;发生错五！查看请求文件名和请求方式！&quot;        &quot;&lt;&#x2F;front&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;;        fputs(protocol,fp);        fputs(server,fp);        fputs(cnt_len,fp);        fputs(cnt_type,fp);        fflush(fp);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（四）</title>
      <link href="/2023/06/02/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/"/>
      <url>/2023/06/02/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</url>
      
        <content type="html"><![CDATA[<h2 id="10-多进程服务器端"><a href="#10-多进程服务器端" class="headerlink" title="10.多进程服务器端"></a>10.多进程服务器端</h2><h3 id="（3）基于多任务的并发服务器"><a href="#（3）基于多任务的并发服务器" class="headerlink" title="（3）基于多任务的并发服务器"></a>（3）基于多任务的并发服务器</h3><p><img src="https://s1.ax1x.com/2023/06/02/pCp99Cq.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char * message);void read_childproc(int sig);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    pid_t pid;    struct sigaction act;    socklen_t adr_sz;    char buf[BUF_SIZE];    int str_len,state;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    act.sa_handler&#x3D;read_childproc;    sigemptyset(&amp;act.sa_mask);    act.sa_flags&#x3D;0;    state&#x3D;sigaction(SIGCHLD, &amp;act, 0);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_adr));    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    while(1)    &#123;        adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             continue;        else             puts(&quot;new client connected...&quot;);        pid&#x3D;fork();        if(pid&#x3D;&#x3D;-1)         &#123;            close(clnt_sock);            continue;        &#125;                            if(pid&#x3D;&#x3D;0)        &#123;            close(serv_sock);            while((str_len&#x3D;read(clnt_sock,buf,BUF_SIZE))!&#x3D;0)                write(clnt_sock,buf,str_len);            close(clnt_sock);            puts(&quot;client disconnected&quot;);            return 0;        &#125;        else            close(clnt_sock);            &#125;        close(serv_sock);    return 0;&#125;   void read_childproc(int sig)&#123;    pid_t pid;    int status;    pid&#x3D;waitpid(-1,&amp;status,WNOHANG);    printf(&quot;removed proc id:%d\n&quot;,pid);&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）分割TCP的I-x2F-O程序"><a href="#（4）分割TCP的I-x2F-O程序" class="headerlink" title="（4）分割TCP的I&#x2F;O程序"></a>（4）分割TCP的I&#x2F;O程序</h3><p>客户端的父进程负责接收数据，额外创建的子进程负责发送数据。 分割后，不同进程分别负责输入和输出，这样，无论客户端是否从服务器端接收完数据都可以进行传输。</p><p><img src="https://s1.ax1x.com/2023/06/02/pCppzUs.png"></p><p>分割程序的另一个好处是，可以频繁交换数据的性能：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9C80.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char * message);void read_routine(int sock,char *buf);void write_routine(int sock,char *buf);int main(int argc,char *argv[])&#123;    int sock;    pid_t pid;    char buf[BUF_SIZE];    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);        if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)        write_routine(sock,buf);    else        read_routine(sock,buf);    close(sock);    return 0;    &#125;void read_routine(int sock,char *buf)&#123;    while(1)    &#123;        int str_len&#x3D;read(sock,buf,BUF_SIZE);            if(str_len&#x3D;&#x3D;0)            return;        buf[str_len]&#x3D;0;&#x2F;&#x2F;和‘&#x2F;0’有啥区别？一定要加这个吗        printf(&quot;message from server:%s\n&quot;,buf);    &#125;&#125;void write_routine(int sock,char *buf)&#123;    while(1)    &#123;        fgets(buf,BUF_SIZE,stdin);        if(!strcmp(buf,&quot;q\n&quot; )|| !strcmp(buf,&quot;Q\n&quot;))        &#123;            shutdown(sock,SHUT_WR);            return;        &#125;        write(sock,buf,strlen(buf));    &#125;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-进程间通信"><a href="#11-进程间通信" class="headerlink" title="11.进程间通信"></a>11.进程间通信</h2><h3 id="（1）通过管道实现进程间通信"><a href="#（1）通过管道实现进程间通信" class="headerlink" title="（1）通过管道实现进程间通信"></a>（1）通过管道实现进程间通信</h3><h4 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int pipe(int filedes[2]);&#x2F;&#x2F;成0，败1&#x2F;&#x2F;filedes[0]通过管道接受数据时使用的文件描述符，即管道出口&#x2F;&#x2F;filedes[1]通过管道传输数据时使用的文件描述符，即管道入口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口的1个文件描述符传递给子进程（调用fork函数）。</p><p>pipe1.c:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds[2];    char str[]&#x3D;&quot;hello&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds[1],str,sizeof(str));    &#125;    else&#123;        read(fds[0],buf,BUF_SIZE);        puts(buf);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图示：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCppxEj.png"></p><h4 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h4><p><img src="https://s1.ax1x.com/2023/06/02/pCppjbQ.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds[2];    char str1[]&#x3D;&quot;hello&quot;;    char str2[]&#x3D;&quot;thank you for your message&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds[1],str1,sizeof(str1));        sleep(2);        read(fds[0],buf,BUF_SIZE);        printf(&quot;child proc output:%s\n&quot;,buf);    &#125;    else    &#123;        read(fds[0],buf,BUF_SIZE);        printf(&quot;parent proc output:%s\n&quot;,buf);        write(fds[1],str2,sizeof(str2));        sleep(3);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>升级成两个管道，各自负责不同的数据流动：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9S5n.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[]) &#123;    int fds1[2],fds2[2];    char str1[]&#x3D;&quot;hello&quot;;    char str2[]&#x3D;&quot;thank you for your message&quot;;    char buf[BUF_SIZE];    pid_t pid;    pipe(fds1),pipe(fds2);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        write(fds1[1],str1,sizeof(str1));        read(fds2[0],buf,BUF_SIZE);        printf(&quot;child proc output:%s\n&quot;,buf);    &#125;    else    &#123;        read(fds1[0],buf,BUF_SIZE);        printf(&quot;parent proc output:%s\n&quot;,buf);        write(fds2[1],str2,sizeof(str2));        sleep(3);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-运用进程间通信"><a href="#2-运用进程间通信" class="headerlink" title="(2)运用进程间通信"></a>(2)运用进程间通信</h3><p><strong>保存消息的回声服务器端</strong> 将回声客户端传输的字符串按序保存到文件中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 100&#x2F;&#x2F;懒得写报错函数了void read_childproc(int sig);int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    int fds[2];    pid_t pid;    struct sigaction act;    socklen_t adr_sz;    int str_len,state;    char buf[BUF_SIZE];    if(argc!&#x3D;2)    &#123;        printf(&quot;usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    act.sa_handler&#x3D;read_childproc;    sigemptyset(&amp;act.sa_mask);    act.sa_flags&#x3D;0;    state&#x3D;sigaction(SIGCHLD,&amp;act,0);    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    memset(&amp;serv_adr,0,sizeof(serv_sock));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));    listen(serv_sock,5);    pipe(fds);    pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)    &#123;        FILE *fp&#x3D;fopen(&quot;echomsg.txt&quot;,&quot;wt&quot;);        char msgbuf[BUF_SIZE];        int len;        for(int i&#x3D;0;i&lt;10;++i)        &#123;            len&#x3D;read(fds[0],msgbuf,BUF_SIZE);            fwrite((void*)msgbuf,1,len,fp);        &#125;        fclose(fp);        return 0;    &#125;    while(1)    &#123;        adr_sz&#x3D;sizeof(clnt_adr);        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)            continue;        else            puts(&quot;new client connection&quot;);        pid&#x3D;fork();        if(pid&#x3D;&#x3D;0)        &#123;            close(serv_sock);            while((str_len&#x3D;read(clnt_sock,buf,BUF_SIZE))!&#x3D;0)            &#123;                write(clnt_sock,buf,str_len);                write(fds[1],buf,str_len);            &#125;            close(clnt_sock);            puts(&quot;clients connected&quot;);            return 0;        &#125;        else             close(clnt_sock);    &#125;    close(serv_sock);    return 0;&#125;void read_childproc(int sig)&#123;    pid_t pid;    int status;    pid&#x3D;waitpid(-1,&amp;status,WNOHANG);    printf(&quot;removed proc id:%d\n&quot;,pid);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-I-x2F-O复用"><a href="#12-I-x2F-O复用" class="headerlink" title="12.I&#x2F;O复用"></a>12.I&#x2F;O复用</h2><h3 id="（1）基于I-x2F-O复用的服务器端"><a href="#（1）基于I-x2F-O复用的服务器端" class="headerlink" title="（1）基于I&#x2F;O复用的服务器端"></a>（1）基于I&#x2F;O复用的服务器端</h3><p>多进程服务器模型：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9P2V.png"></p><p>I&#x2F;O复用服务器模型：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9ivT.png"></p><h3 id="（2）理解select函数并实现服务器端"><a href="#（2）理解select函数并实现服务器端" class="headerlink" title="（2）理解select函数并实现服务器端"></a>（2）理解select函数并实现服务器端</h3><p>select函数调用方法和顺序：</p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9kKU.png"></p><h4 id="设置文件描述符"><a href="#设置文件描述符" class="headerlink" title="设置文件描述符"></a>设置文件描述符</h4><p>fd_set变量中注册和更改值由以下宏完成：<br><img src="https://s1.ax1x.com/2023/06/02/pCp9ZVJ.png"></p><p><img src="https://s1.ax1x.com/2023/06/02/pCp9Eb4.png"></p><h4 id="设置监视范围与超时"><a href="#设置监视范围与超时" class="headerlink" title="设置监视范围与超时"></a>设置监视范围与超时</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;select.h&gt;#include&lt;sys&#x2F;time.h&gt;int select(    int maxfd,fd_set * readset,fd_set * writeset,fd_set * exceptset,const struct timeval * timeout);&#x2F;&#x2F;成返回大于0的值，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/pCp9ea9.png"></p><p>timeval结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct timeval&#123;    long tv_sec;    long tv_usec;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="select函数调用示例"><a href="#select函数调用示例" class="headerlink" title="select函数调用示例"></a>select函数调用示例</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;time.h&gt;#include&lt;sys&#x2F;select.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[])&#123;    fd_set reads,temps;    int result,str_len;    char buf[BUF_SIZE];    struct timeval timeout;    FD_ZERO(&amp;reads);    FD_SET(0,&amp;reads);&#x2F;&#x2F;0 is standard input(console);    while(1)    &#123;        temps&#x3D;reads;        timeout.tv_sec&#x3D;5;        timeout.tv_usec&#x3D;0;        result&#x3D;select(1,&amp;temps,0,0,&amp;timeout);        if(result&#x3D;&#x3D;-1)        &#123;            puts(&quot;select() error&quot;);            break;        &#125;        else if(result&#x3D;&#x3D;0)        &#123;            puts(&quot;timeout&quot;);        &#125;        else        &#123;            if(FD_ISSET(0,&amp;temps))            &#123;                str_len&#x3D;read(0,buf,BUF_SIZE);                buf[str_len]&#x3D;0;                printf(&quot;message from console: %s\n&quot;,buf);            &#125;                    &#125;    &#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现I-x2F-O复用服务器端"><a href="#实现I-x2F-O复用服务器端" class="headerlink" title="实现I&#x2F;O复用服务器端"></a>实现I&#x2F;O复用服务器端</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;time.h&gt;#include&lt;sys&#x2F;select.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 100&#x2F;&#x2F;报错函数懒得写了int main(int argc, char *argv[])&#123;    int serv_sock,clnt_sock;    struct sockaddr_in serv_adr,clnt_adr;    struct timeval timeout;    fd_set reads,cpy_reads;    socklen_t adr_sz;    int fd_max,str_len,fd_num;    char buf[BUF_SIZE];    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));    listen(serv_sock,5);    FD_ZERO(&amp;reads);    FD_SET(serv_sock,&amp;reads);    fd_max&#x3D;serv_sock;    while(1)    &#123;        cpy_reads&#x3D;reads;        timeout.tv_sec&#x3D;5;        timeout.tv_usec&#x3D;5000;        if((fd_num&#x3D;select(fd_max+1,&amp;cpy_reads,0,0,&amp;timeout))&#x3D;&#x3D;-1)            break;        if(fd_num&#x3D;&#x3D;0)        &#123;            continue;        &#125;        for(int i&#x3D;0; i&lt;fd_max+1; ++i)        &#123;            if(FD_ISSET(i,&amp;cpy_reads))            &#123;                if(i&#x3D;&#x3D;serv_sock)&#x2F;&#x2F;connection request                &#123;                    adr_sz&#x3D;sizeof(clnt_adr);                    clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz);                    FD_SET(clnt_sock,&amp;reads);                    if(fd_max&lt;clnt_sock)                        fd_max&#x3D;clnt_sock;                    printf(&quot;connected client:%d\n&quot;,clnt_sock);                &#125;                else&#x2F;&#x2F;read message                &#123;                    str_len&#x3D;read(i,buf,BUF_SIZE);                    if(str_len&#x3D;&#x3D;0)&#x2F;&#x2F;close request                    &#123;                                                FD_CLR(i,&amp;reads);                        close(i);                        printf(&quot;closed client:%d\n&quot;,i);                    &#125;                    else                    &#123;                        write(i,buf,str_len);&#x2F;&#x2F;echo                    &#125;                                                           &#125;            &#125;        &#125;    &#125;    close(serv_sock);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（三）</title>
      <link href="/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2023/06/01/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<h2 id="9-套接字的多种可选项"><a href="#9-套接字的多种可选项" class="headerlink" title="9.套接字的多种可选项"></a>9.套接字的多种可选项</h2><h3 id="（1）套接字的多种可选项："><a href="#（1）套接字的多种可选项：" class="headerlink" title="（1）套接字的多种可选项："></a>（1）套接字的多种可选项：</h3><p><img src="https://s1.ax1x.com/2023/06/02/p9zh7Gt.png"><br><img src="https://s1.ax1x.com/2023/06/02/p9z4pin.png"></p><h3 id="（2）getsocket-amp-setsocket"><a href="#（2）getsocket-amp-setsocket" class="headerlink" title="（2）getsocket &amp; setsocket"></a>（2）getsocket &amp; setsocket</h3><p>可选项的的读取和设置由以下两个函数完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int getsockopt(int sock,int level,int optname,void *optval,socklen_t *optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhIIA.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int setsockopt(int sock,int level,int optname,const void *optval,socklen_t optlen);&#x2F;&#x2F;成0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhHRP.png"></p><h4 id="用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）："><a href="#用协议层为SOL-SOCKET-x2F-名为SO-TYPE的可选项查看套接字类型（sock-type-c）：" class="headerlink" title="用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）："></a>用协议层为SOL_SOCKET&#x2F;名为SO_TYPE的可选项查看套接字类型（sock_type.c）：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;socket.h&gt;void error_handling(char *message);int main(int argc, char *argv[])&#123;    int tcp_sock,udp_sock;    int sock_type;    socklen_t optlen;    int state;    optlen&#x3D;sizeof(sock_type);    tcp_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    udp_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    printf(&quot;SOCK_STREAM:%d\n&quot;,SOCK_STREAM);    printf(&quot;SOCK_DGRAM:%d\n&quot;,SOCK_DGRAM);    state&#x3D;getsockopt(tcp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type one:%d\n&quot;,sock_type);        state&#x3D;getsockopt(udp_sock,SOL_SOCKET,SO_TYPE,(void *)&amp;sock_type,&amp;optlen);    if(state)        error_handling(&quot;getsockopt error&quot;);    printf(&quot;socket type two:%d\n&quot;,sock_type);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhTPI.png"></p><h3 id="（3）SO-SNDBUF-amp-SO-RCVBUF"><a href="#（3）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="（3）SO_SNDBUF &amp; SO_RCVBUF"></a>（3）SO_SNDBUF &amp; SO_RCVBUF</h3><p> 前者是输入缓冲大小相关可选项，后者输出的，这两个可选项既可以读取当前I&#x2F;O缓冲大小，也可以进行更改。（代码和上面差不多）</p><h3 id="（4）SO-REUSEADDR"><a href="#（4）SO-REUSEADDR" class="headerlink" title="（4）SO_REUSEADDR"></a>（4）SO_REUSEADDR</h3><p> 假设主机A的四次握手过程中最后的数据丢失，则主机B会认为A未能收到自己发送的FIN消息，因此重传。此时收到FIN消息的主机A将重启Time_wait计时器。所以网络状况不理想的话，Time_wait状态将持续。</p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhbxf.png"></p><p>解决方法就是在套接字的可选项中更改SO_REUSEADDR的状态，将默认值0改为:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">optlen&#x3D;sizeof(option);option&#x3D;TRUE;setsockopt(serv_sock,SOL_SOCKET,SO_REUSEADDR,(void*)&amp;option,optlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（5）TCP-NODELAY"><a href="#（5）TCP-NODELAY" class="headerlink" title="（5）TCP_NODELAY"></a>（5）TCP_NODELAY</h3><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p><img src="https://s1.ax1x.com/2023/06/02/p9zhLM8.png"></p><p>但传输大文件数据时即使不使用该算法也会在装满缓冲时传输数据包，这样不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。</p><h4 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">int opt_val&#x3D;1;setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(void *)&amp;opt_val,sizeof(opt_val));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="10-多进程服务器端"><a href="#10-多进程服务器端" class="headerlink" title="10.多进程服务器端"></a>10.多进程服务器端</h2><h3 id="（1）进程"><a href="#（1）进程" class="headerlink" title="（1）进程"></a>（1）进程</h3><h4 id="并发服务器的实现方法"><a href="#并发服务器的实现方法" class="headerlink" title="并发服务器的实现方法"></a>并发服务器的实现方法</h4><p>如下图所示：（多进程服务器Windows平台不支持）<br><img src="https://s1.ax1x.com/2023/06/02/p9zhxaj.png"></p><h4 id="调用fork函数创建进程"><a href="#调用fork函数创建进程" class="headerlink" title="调用fork函数创建进程"></a>调用fork函数创建进程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;pid_t fork(void);&#x2F;&#x2F;成进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过同一个进程复制相同的内存空间，之后的程序要根据返回值加以区分：</p><p>父进程：fork函数返回子进程id</p><p>子进程：fork函数返回0</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>为了摧毁子进程，父进程应主动请求获取子进程的返回值，<strong>方法其一</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t wait(int* statloc);&#x2F;&#x2F;成子进程ID，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用此函数如果有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值&#x2F;main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离：</p><p>WIFEXITED:子进程正常终止时返回true</p><p>WEXITSTATUS：返回子进程的返回值</p><p>向wait函数传递变量status的地址时，调用wait函数后应编写如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(WIFEXITED(status))&#123;    puts(&quot;normal termination&quot;);    printf(&quot;child pass num:%d&quot;,WEXITSTATUS(status));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用wait函数时，如果没有已终止的子进程，那么程序将阻塞直到有子进程终止，谨慎使用。</p><p><strong>方法其二</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;wait.h&gt;pid_t waitpid(pid_t pid,int *statloc,int options);&#x2F;&#x2F;成返回终止的子进程id或0，败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhOsS.png"></p><h3 id="（2）信号处理"><a href="#（2）信号处理" class="headerlink" title="（2）信号处理"></a>（2）信号处理</h3><p>进程发现自己的子进程结束时，请求操作系统调用特定函数（信号注册函数）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;void (*signal(int signo,void(*func)(int)))(int);&#x2F;&#x2F;为了在产生信号时调用，返回之前注册的函数指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhXqg.png"></p><p><img src="https://s1.ax1x.com/2023/06/02/p9zhvZQ.png"></p><h4 id="编写signal函数"><a href="#编写signal函数" class="headerlink" title="编写signal函数"></a>编写signal函数</h4><p><strong>请求</strong> 已到通过alarm函数注册的时间，调用timeout函数；输入CTRL+C时调用keycontrol函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void timeout(int sig)&#123;    if(sig&#x3D;&#x3D;SIGALRM)        puts(&quot;time out&quot;);    alarm(2);&#125;void keycontrol(int sig)&#123;    if(sig&#x3D;&#x3D;SIGINT)        puts(&quot;CTRL+C pressed&quot;);&#125;int main(int argc,char *argv[])&#123;    signal(SIGALRM,timeout);    signal(SIGINT,keycontrol);    alarm(2);    for(int i&#x3D;0;i&lt;3;++i)    &#123;        puts(&quot;wait....&quot;);        sleep(100);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9zhzIs.png"></p><h4 id="利用sigaction函数进行信号处理-更稳定"><a href="#利用sigaction函数进行信号处理-更稳定" class="headerlink" title="利用sigaction函数进行信号处理(更稳定)"></a>利用sigaction函数进行信号处理(更稳定)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;signal.h&gt;int sigaction(int signo,const struct sigaction *act,struct sigaction * oldact);&#x2F;&#x2F;成0，败1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/06/02/p9z49Gq.png"></p><p>声明并初始化sigaction结构体变量以调用上述函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sigaction&#123;    void (*sa_handler)(int);    sigset_t sa_mask;    int sa_flags;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（二）</title>
      <link href="/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2023/05/31/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h2 id="6-基于UDP的服务器端-x2F-客户端"><a href="#6-基于UDP的服务器端-x2F-客户端" class="headerlink" title="6.基于UDP的服务器端&#x2F;客户端"></a>6.基于UDP的服务器端&#x2F;客户端</h2><h3 id="（1）基于UDP的数据I-x2F-O函数"><a href="#（1）基于UDP的数据I-x2F-O函数" class="headerlink" title="（1）基于UDP的数据I&#x2F;O函数"></a>（1）基于UDP的数据I&#x2F;O函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t sendto(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *to,socklen_t addrlen);&#x2F;&#x2F;成功时返回传输的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYf1K.png"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;ssize_t recvfrom(int sock,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t addrlen);&#x2F;&#x2F;成功接受的字节数，失败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYIne.png"></p><h3 id="2-基于UDP的回声服务器端-x2F-客户端"><a href="#2-基于UDP的回声服务器端-x2F-客户端" class="headerlink" title="(2)基于UDP的回声服务器端&#x2F;客户端"></a>(2)基于UDP的回声服务器端&#x2F;客户端</h3><p>sendto函数自动分配IP和端口号，所以UDP客户端中通常无需额外的地址分配过程</p><p>服务器端：uechos.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int serv_sock;    char message[BUF_SIZE];    int str_len;    socklen_t clnt_adr_sz;    struct sockaddr_in serv_adr,clnt_adr;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(serv_sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;binding error&quot;);    &#125;    while(1)    &#123;        clnt_adr_sz&#x3D;sizeof(clnt_adr);        str_len&#x3D;recvfrom(serv_sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        sendto(serv_sock,message,str_len,0,(struct sockaddr*)&amp;clnt_adr,clnt_adr_sz);    &#125;    close(serv_sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：uechoc.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 30void error_handling(char *message);int main(int argc, char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    socklen_t adr_sz;    struct sockaddr_in serv_adr,from_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);    if(sock&#x3D;&#x3D;-1) error_handling(&quot;socket creation error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    while(1)    &#123;        fputs(&quot;insert ,message(q to quit):&quot;,stdout);        fgets(message,sizeof(message),stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;        sendto(sock,message,strlen(message),0,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr));        adr_sz&#x3D;sizeof(from_adr);        str_len&#x3D;recvfrom(sock,message,BUF_SIZE,0,(struct sockaddr*)&amp;from_adr,&amp;adr_sz);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server:%s&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYHAA.png"></p><h3 id="（3）已连接UDP套接字与未连接UDP套接字"><a href="#（3）已连接UDP套接字与未连接UDP套接字" class="headerlink" title="（3）已连接UDP套接字与未连接UDP套接字"></a>（3）已连接UDP套接字与未连接UDP套接字</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9xYo0H.png"></p><p>每次调用sendto函数重复上述过程，每次都变更目标地址，因此可以重复利用同一套UDP套接字向不同目标传输数据。这种未注册目标地点信息的套接字称为未连接套接字。</p><p>创建已连接UDP套接字：</p><pre class="line-numbers language-none"><code class="language-none">sock&#x3D;socket(PF_INET,SOCK_DGRAM,0);memset(&amp;adr,0,sizeof(adr));adr.sin_family&#x3D;AF_INET;adr.sin_addr.s_addr&#x3D;...adr.sin_port&#x3D;...connect(sock,(struct sockaddr*)&amp;adr,sizeof(adr));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后与TCP套接字一样，每次调用sendto函数时只需传输数据。因为已经指定了收发对象，所以还可以使用write,read函数进行通信。</p><h2 id="7-优雅地断开套接字的连接"><a href="#7-优雅地断开套接字的连接" class="headerlink" title="7.优雅地断开套接字的连接"></a>7.优雅地断开套接字的连接</h2><h3 id="1-shutdown函数"><a href="#1-shutdown函数" class="headerlink" title="(1)shutdown函数"></a>(1)shutdown函数</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;int shutdown(int sock,int howto);&#x2F;&#x2F;成0败-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二个值：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xY4XD.png"></p><h3 id="2-半关闭"><a href="#2-半关闭" class="headerlink" title="(2)半关闭"></a>(2)半关闭</h3><p>调用close函数的同时关闭I&#x2F;O流，这样也会向对方发送EOF，但此时无法接受对方传输的数据。调用shutdown函数只关闭输出流，这样既可以发送EOF，又保留了输入流，可以接受对方数据。</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYO9P.png"></p><h2 id="8-域名及网络地址"><a href="#8-域名及网络地址" class="headerlink" title="8.域名及网络地址"></a>8.域名及网络地址</h2><h3 id="（1）域名系统"><a href="#（1）域名系统" class="headerlink" title="（1）域名系统"></a>（1）域名系统</h3><h4 id="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"><a href="#DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。" class="headerlink" title="DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。"></a>DNS是对IP地址和域名进行相互转换的系统，核心为DNS服务器。</h4><p>域名：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYT7d.png"></p><p>DNS获取IP地址信息：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9xYqht.png"></p><h3 id="（2）利用域名获取IP地址："><a href="#（2）利用域名获取IP地址：" class="headerlink" title="（2）利用域名获取IP地址："></a>（2）利用域名获取IP地址：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyname(const char * hostname);&#x2F;&#x2F;成hostent结构体地址，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hostent结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hostent&#123;    char * h_name;&#x2F;&#x2F;官方域名    char ** h_aliases;&#x2F;&#x2F;alias list,同一个IP可以绑定多个域名    int h_addrtype;&#x2F;&#x2F;host address type    int h_length;&#x2F;&#x2F;保存IP地址长度    char ** h_addr_list;&#x2F;&#x2F;最重要的成员，通过此变量以整数形式保存域名对应的IP地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9xYbtI.png"></p><h3 id="（3）利用IP地址获取域名："><a href="#（3）利用IP地址获取域名：" class="headerlink" title="（3）利用IP地址获取域名："></a>（3）利用IP地址获取域名：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;netdb.h&gt;struct hostent * gethostbyaddr(const char *addr,socklen_t len,int family);&#x2F;&#x2F;成hostent结构体地址值，败NULL指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络编程（一）</title>
      <link href="/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2023/05/30/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>前言：该内容基于Linux平台，且笔记比较精简，省略了笔者大量思考内容，但有助于知识点复盘。</p><h2 id="1-网络编程与套接字"><a href="#1-网络编程与套接字" class="headerlink" title="1.网络编程与套接字"></a>1.网络编程与套接字</h2><h3 id="（1）调用socket函数创建套接字："><a href="#（1）调用socket函数创建套接字：" class="headerlink" title="（1）调用socket函数创建套接字："></a>（1）调用socket函数创建套接字：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（2）调用-bind-函数分配IP地址和端口号："><a href="#（2）调用-bind-函数分配IP地址和端口号：" class="headerlink" title="（2）调用 bind 函数分配IP地址和端口号："></a>（2）调用 bind 函数分配IP地址和端口号：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket.h&gt; int bind(int sockfd, strcuct sockaddr *myaddr, socklen_t addrlen);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）调用listen函数转为可接受请求状态："><a href="#（3）调用listen函数转为可接受请求状态：" class="headerlink" title="（3）调用listen函数转为可接受请求状态："></a>（3）调用listen函数转为可接受请求状态：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int listen(int sockfd,int backlog);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）调用accept函数受理连接请求："><a href="#（4）调用accept函数受理连接请求：" class="headerlink" title="（4）调用accept函数受理连接请求："></a>（4）调用accept函数受理连接请求：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-基于Linux的文件操作"><a href="#2-基于Linux的文件操作" class="headerlink" title="2.基于Linux的文件操作"></a>2.基于Linux的文件操作</h2><h3 id="（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）"><a href="#（1）底层文件访问（Low-Level-File-Access）和文件描述符（File-Descriptor）" class="headerlink" title="（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）"></a>（1）底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）</h3><p>分配给标准输入输出及标准错误的文件描述符：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsq29.png"></p><h3 id="（2）打开文件"><a href="#（2）打开文件" class="headerlink" title="（2）打开文件"></a>（2）打开文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#include&lt;fcntl.h&gt;int open(const char *path,int flag);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag可能的值与含义：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsLvR.png"></p><h3 id="（3）关闭文件"><a href="#（3）关闭文件" class="headerlink" title="（3）关闭文件"></a>（3）关闭文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;int close(int fd);&#x2F;&#x2F;成功时返回0，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）将数据写入文件"><a href="#（4）将数据写入文件" class="headerlink" title="（4）将数据写入文件"></a>（4）将数据写入文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）读取文件中的数据"><a href="#（4）读取文件中的数据" class="headerlink" title="（4）读取文件中的数据"></a>（4）读取文件中的数据</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t nbytes);&#x2F;&#x2F;成功时返回写入的字节数（但遇到文件结尾则返回0），失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-套接字类型与协议设置"><a href="#3-套接字类型与协议设置" class="headerlink" title="3.套接字类型与协议设置"></a>3.套接字类型与协议设置</h2><h3 id="（1）协议族"><a href="#（1）协议族" class="headerlink" title="（1）协议族"></a>（1）协议族</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys&#x2F;socket. h&gt; int socket(int domain, int type, int protocol);&#x2F;&#x2F;成功时返回文件描述符，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2023/05/31/p9vsb8J.png"></p><p>一般只用PF_INET(IPv4互联网协议族)</p><h3 id="（2）套接字类型"><a href="#（2）套接字类型" class="headerlink" title="（2）套接字类型"></a>（2）套接字类型</h3><p>SOCK_STREAM(面向连接):</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsHC4.png"></p><p>SOCK_SGRAM（面向消息）:</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsT5F.png"></p><p>*第三个参数一般为0（数据传输方式相同， 但协议不同。 此时需要通过第3个参数具体指定协议信息）</p><h2 id="4-地址族与数据序列"><a href="#4-地址族与数据序列" class="headerlink" title="4.地址族与数据序列"></a>4.地址族与数据序列</h2><h3 id="（1）表示IPv4地址的结构体"><a href="#（1）表示IPv4地址的结构体" class="headerlink" title="（1）表示IPv4地址的结构体"></a>（1）表示IPv4地址的结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">stuct sockaddr_in &#123;    sa_family_t sin_family sin_family;&#x2F;&#x2F;地址族（Address Family）    uint16_t         sin_port;&#x2F;&#x2F;16位TCP&#x2F;UDP端口号    struct in_addr   sin_addr;&#x2F;&#x2F;32位IP地址    char             sin_zero[0];&#x2F;&#x2F;不使用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct in_addr&#123;    in_addr_t    s_addr;&#x2F;&#x2F;32位IPv4地址&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*POSIX中定义的数据类型（用于提高扩展性）</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vsjDx.png"></p><h3 id="（2）结构体sockaddr-in成员分析"><a href="#（2）结构体sockaddr-in成员分析" class="headerlink" title="（2）结构体sockaddr_in成员分析"></a>（2）结构体sockaddr_in成员分析</h3><p>sin_family：地址族，一般为AF_INET</p><p>sin_port：保存16位端口</p><p>sin_addr：保存32位IP地址信息</p><h3 id="（3）网络字节序"><a href="#（3）网络字节序" class="headerlink" title="（3）网络字节序"></a>（3）网络字节序</h3><p>网络字节序位为大端模式，主机字节序为小端模式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned short htons(unsigned short); unsigned short ntohs(unsîgned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>h代表主机字节序，n代表网络字节序</p><h3 id="（4）网络地址的初始化与分配"><a href="#（4）网络地址的初始化与分配" class="headerlink" title="（4）网络地址的初始化与分配"></a>（4）网络地址的初始化与分配</h3><p>将字符串形式的IP地址转换成32位整数型数据（此类型在转换类型的同时进行网络字节序转换）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int_addr_t inet_addr(const char* string);&#x2F;&#x2F;成功时返回32位大端序整数型值，失败时返回INADDR_NODE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_aton(const char* string,struct in_addr *addr);&#x2F;&#x2F;成功时返回1，失败时返回0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>*后者传递in_addr结构体变量地址值，函数会自动把结果填入该结构体得到变量，所以使用频率更高。</p><p>反过来转换：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;arpa&#x2F;inet.h&gt;int inet_ntoa(struct in_addr adr);&#x2F;&#x2F;成功时返回转换的字符串地址值，失败时返回-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建套接字常见的网络地址信息初始化方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sockaddr_in addr; char * serv_ip &#x3D; &quot;211.117.168.13&quot;;     &#x2F;&#x2F;声明 IP 地址字符串char * serv_port &#x3D; &quot;9190&quot;;           &#x2F;&#x2F;声明端口号字符串memset(&amp;addr, 0 , sizeof(addr));     &#x2F;&#x2F;结构体addr的所有成员初始化为0addr.sin_family &#x3D; AF_INET;           &#x2F;&#x2F; 指定地址族addr.sin_addr.s_addr &#x3D; inet_addr(serv_ip);  &#x2F;&#x2F;基于字符串IP地址初始化addr.sin_port &#x3D; htons(atoi(serv_port));     &#x2F;&#x2F;基于字符串的端口号初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次创建服务器端套接字都要输入 地址会有些繁琐，此时可如下初始化地址信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct sckaddr_in addr;char * serv_port &#x3D;&quot;9190&quot;;memset(&amp;addr,0,szieof(addr));addr.sin_family&#x3D;AF_INET;addr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);addr.sin_port&#x3D;htons(atoi(serv_port));&#x2F;&#x2F;利用常数可自动获取服务器端的计算机IP，不用手动输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-基于TCP的服务器端-x2F-客户端"><a href="#5-基于TCP的服务器端-x2F-客户端" class="headerlink" title="5.基于TCP的服务器端&#x2F;客户端"></a>5.基于TCP的服务器端&#x2F;客户端</h2><h3 id="（1）TCP-服务器端-x2F-客户端的函数调用关系"><a href="#（1）TCP-服务器端-x2F-客户端的函数调用关系" class="headerlink" title="（1）TCP 服务器端&#x2F;客户端的函数调用关系"></a>（1）TCP 服务器端&#x2F;客户端的函数调用关系</h3><p><img src="https://s1.ax1x.com/2023/05/31/p9vyCPe.png"></p><h3 id="（2）迭代回声服务器-x2F-客户端"><a href="#（2）迭代回声服务器-x2F-客户端" class="headerlink" title="（2）迭代回声服务器&#x2F;客户端"></a>（2）迭代回声服务器&#x2F;客户端</h3><p>程序基本运行方式：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyp5D.png"><br>服务器端(echo_sever.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc!&#x3D;2)    &#123;        printf(&quot;Usage:%s&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(serv_sock&#x3D;&#x3D;-1)         error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)         error_handling(&quot;bind()  error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1) &#x2F;&#x2F;同一时间服务器能接收到客户端请求的最大数量为5        error_handling(&quot;listen() error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;++i)    &#123;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;clnt_adr_sz);        if(clnt_sock&#x3D;&#x3D;-1)             error_handling(&quot;accept() error&quot;);        else            printf(&quot;connect client %d\n&quot;,i+1);        while((str_len&#x3D;read(clnt_sock,message,BUF_SIZE))!&#x3D;0)            write(clnt_sock,message,str_len);        close(clnt_sock);        return 0;    &#125;    close(serv_sock);    return 0;&#125;   void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端(echo_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024void error_handling(char * message);int main(int argc,char *argv[])&#123;    int sock;    char message[BUF_SIZE];    int str_len;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;Usage: %s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET, SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)    &#123;        error_handling(&quot;socket() error&quot;);    &#125;    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error!&quot;);    else        puts(&quot;Connect&quot;);    while(1)    &#123;        fputs(&quot;input message(Q to quit):&quot;,stdout);        fgets(message,BUF_SIZE,stdin);        if(!strcmp(message,&quot;q\n&quot; )|| !strcmp(message,&quot;Q\n&quot;))            break;                write(sock,message,strlen(message));        str_len&#x3D;read(sock,message,BUF_SIZE-1);        message[str_len]&#x3D;&#39;\0&#39;;        printf(&quot;message from server %s\n&quot;,message);    &#125;    close(sock);    return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回声客户端存在的问题：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyi2d.png"></p><p>修改迭代部分：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyAKI.png"></p><h3 id="（3）计算器服务器端-x2F-客户端示例"><a href="#（3）计算器服务器端-x2F-客户端示例" class="headerlink" title="（3）计算器服务器端&#x2F;客户端示例"></a>（3）计算器服务器端&#x2F;客户端示例</h3><p>客户端设计如下应用层协议：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyP8H.png"></p><p>客户端(op_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define RLT_SIZE 4#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int main(int argc,char *argv[])&#123;    int sock;    char opmsg[BUF_SIZE];    int result,opnd_cnt;    struct sockaddr_in serv_adr;    if(argc!&#x3D;3)    &#123;        printf(&quot;usage:%s&lt;IP&gt;&lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    sock&#x3D;socket(PF_INET,SOCK_STREAM,0);    if(sock&#x3D;&#x3D;-1)        error_handling(&quot;socket() error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;inet_addr(argv[1]);    serv_adr.sin_port&#x3D;htons(atoi(argv[2]));    if(connect(sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;connect() error&quot;);    else       fputs(&quot;operand count:&quot;,stdout);       scanf(&quot;%d&quot;,&amp;opnd_cnt);       opmsg[0]&#x3D;(char)opnd_cnt;       for(int i&#x3D;0;i&lt;opnd_cnt;++i)       &#123;        printf(&quot;operand %d:&quot;,i+1);        scanf(&quot;%d&quot;,(int*)&amp;opmsg[i*OPSZ+1]);       &#125;       fgetc(stdin);       fputs(&quot;operator:&quot;,stdout);       scanf(&quot;%c&quot;,&amp;opmsg[opnd_cnt*OPSZ+1]);       write(sock,opmsg,opnd_cnt*OPSZ+2);       read(sock,&amp;result,RLT_SIZE);       printf(&quot;operation result:%d\n&quot;,result);       close(sock);       return 0;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端(op_server.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;sys&#x2F;socket.h&gt;#define BUF_SIZE 1024#define OPSZ 4void error_handling(char *message);int calculate(int opnum,int opnds[],char oprator);int main(int argc,char *argv[])&#123;    int serv_sock,clnt_sock;    char opinfo[BUF_SIZE];    int result,opnd_cnt;    int recv_cnt,recv_len;    struct sockaddr_in serv_adr,clnt_adr;    socklen_t clnt_adr_sz;    if(argc !&#x3D;2)    &#123;        printf(&quot;Usage: %s &lt;port&gt;\n&quot;,argv[0]);        exit(1);    &#125;    serv_sock&#x3D;socket(PF_INET, SOCK_STREAM, 0);    if(serv_sock&#x3D;&#x3D;-1)        error_handling(&quot;socket error&quot;);    memset(&amp;serv_adr,0,sizeof(serv_adr));    serv_adr.sin_family&#x3D;AF_INET;    serv_adr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);    serv_adr.sin_port&#x3D;htons(atoi(argv[1]));    if(bind(serv_sock,(struct sockaddr *)&amp;serv_adr,sizeof(serv_adr))&#x3D;&#x3D;-1)        error_handling(&quot;bind error&quot;);    if(listen(serv_sock,5)&#x3D;&#x3D;-1)        error_handling(&quot;listen error&quot;);    clnt_adr_sz&#x3D;sizeof(clnt_adr);    for(int i&#x3D;0;i&lt;5;i++)    &#123;        opnd_cnt&#x3D;0;        clnt_sock&#x3D;accept(serv_sock,(struct sockaddr *)&amp;clnt_adr,&amp;clnt_adr_sz);        read(clnt_sock,&amp;opnd_cnt,1);        recv_len&#x3D;0;        while((opnd_cnt*OPSZ+1)&gt;recv_len)        &#123;            recv_cnt&#x3D;read(clnt_sock,&amp;opinfo[recv_len],BUF_SIZE-1);            recv_len+&#x3D;recv_cnt;        &#125;        result&#x3D;calculate(opnd_cnt,(int*)opinfo,opinfo[recv_len-1]);        write(clnt_sock,(char*)&amp;result,sizeof(result));        close(clnt_sock);                &#125;    close(serv_sock);    return 0;&#125;int calculate(int opnum,int opnds[],char op)&#123;    int result&#x3D;opnds[0];    switch(op)    &#123;        case &#39;+&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result+&#x3D;opnds[i];            break;        case &#39;-&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result-&#x3D;opnds[i];            break;        case &#39;*&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result*&#x3D;opnds[i];            break;        case &#39;&#x2F;&#39;:            for(int i&#x3D;1;i&lt;opnum;i++)                result&#x2F;&#x3D;opnds[i];            break;    &#125;    return result;;&#125;void error_handling(char* message)&#123;    fputs(message,stderr);    fputc(&#39;\n&#39;,stderr);    exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（4）TCP内部工作原理"><a href="#（4）TCP内部工作原理" class="headerlink" title="（4）TCP内部工作原理"></a>（4）TCP内部工作原理</h3><p>a.与对方套接字的连接（三次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyFxA.png"></p><p>套接字是以全双工（Full-duplex）方式工作的，可以双向传递数据。</p><p>b.与对方主机的数据交换：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vyErt.png"></p><p>有超时重传机制</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgLFK.png"></p><p>c.断开与套接字的连接（四次握手）：</p><p><img src="https://s1.ax1x.com/2023/05/31/p9vgfWF.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
